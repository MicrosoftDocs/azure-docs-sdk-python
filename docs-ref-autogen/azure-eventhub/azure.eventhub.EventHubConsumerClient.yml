### YamlMime:PythonClass
uid: azure.eventhub.EventHubConsumerClient
name: EventHubConsumerClient
fullName: azure.eventhub.EventHubConsumerClient
module: azure.eventhub
inheritances:
- azure.eventhub._client_base.ClientBase
summary: 'The EventHubConsumerClient class defines a high level interface for

  receiving events from the Azure Event Hubs service.


  The main goal of *EventHubConsumerClient* is to receive events from all partitions
  of an EventHub with

  load-balancing and checkpointing.


  When multiple *EventHubConsumerClient* instances are running against the same event
  hub, consumer group and

  checkpointing location, the partitions will be evenly distributed among them.


  To enable load-balancing and persisted checkpoints, checkpoint_store must be set
  when creating the

  *EventHubConsumerClient*.

  If a checkpoint store is not provided, the checkpoint will be maintained internally
  in memory.


  An *EventHubConsumerClient* can also receive from a specific partition when you
  call its method *receive()* or

  *receive_batch()* and specify the partition_id.

  Load-balancing won''t work in single-partition mode. But users can still save checkpoints
  if the checkpoint_store

  is set.'
constructor:
  syntax: 'EventHubConsumerClient(fully_qualified_namespace: str, eventhub_name: str,
    consumer_group: str, credential: CredentialTypes, **kwargs: Any)'
  parameters:
  - name: fully_qualified_namespace
    description: 'The fully qualified host name for the Event Hubs namespace.

      The namespace format is: *<yournamespace>.servicebus.windows.net*.'
    isRequired: true
    types:
    - <xref:str>
  - name: eventhub_name
    description: The path of the specific Event Hub to connect the client to.
    isRequired: true
    types:
    - <xref:str>
  - name: consumer_group
    description: Receive events from the event hub for this consumer group.
    isRequired: true
    types:
    - <xref:str>
  - name: credential
    description: 'The credential object used for authentication which

      implements a particular interface for getting tokens. It accepts

      <xref:azure.eventhub.EventHubSharedKeyCredential>, or credential objects generated

      by the azure-identity library and objects that implement the *get_token(self,
      *scopes)* method.'
    isRequired: true
    types:
    - <xref:azure.core.credentials.TokenCredential>
    - <xref:azure.core.credentials.AzureSasCredential>
    - <xref:azure.core.credentials.AzureNamedKeyCredential>
  - name: logging_enable
    description: Whether to output network trace logs to the logger. Default is *False*.
    types:
    - <xref:bool>
  - name: auth_timeout
    description: 'The time in seconds to wait for a token to be authorized by the
      service.

      The default value is 60 seconds. If set to 0, no timeout will be enforced from
      the client.'
    types:
    - <xref:float>
  - name: user_agent
    description: If specified, this will be added in front of the user agent string.
    types:
    - <xref:str>
  - name: retry_total
    description: 'The total number of attempts to redo a failed operation when an
      error occurs.

      Default value is 3. The context of *retry_total* in receiving is special: The
      *receive* method is implemented

      by a while-loop calling internal receive method in each iteration. In the *receive*
      case,

      *retry_total* specifies the numbers of retry after error raised by internal
      receive method in the while-loop.

      If retry attempts are exhausted, the *on_error* callback will be called (if
      provided) with the error information.

      The failed internal partition consumer will be closed (*on_partition_close*
      will be called if provided) and

      new internal partition consumer will be created (*on_partition_initialize* will
      be called if provided) to resume

      receiving.'
    types:
    - <xref:int>
  - name: retry_backoff_factor
    description: 'A backoff factor to apply between attempts after the second try

      (most errors are resolved immediately by a second try without a delay).

      In fixed mode, retry policy will always sleep for {backoff factor}.

      In ''exponential'' mode, retry policy will sleep for: *{backoff factor} * (2
      ** ({number of total retries} - 1))*

      seconds. If the backoff_factor is 0.1, then the retry will sleep

      for [0.0s, 0.2s, 0.4s, ...] between retries. The default value is 0.8.'
    types:
    - <xref:float>
  - name: retry_backoff_max
    description: The maximum back off time. Default value is 120 seconds (2 minutes).
    types:
    - <xref:float>
  - name: retry_mode
    description: 'The delay behavior between retry attempts. Supported values are
      ''fixed'' or ''exponential'',

      where default is ''exponential''.'
    types:
    - <xref:str>
  - name: idle_timeout
    description: 'Timeout, in seconds, after which this client will close the underlying
      connection

      if there is no further activity. By default the value is None, meaning that
      the client will not shutdown due to

      inactivity unless initiated by the service.'
    types:
    - <xref:float>
  - name: transport_type
    description: 'The type of transport protocol that will be used for communicating
      with

      the Event Hubs service. Default is *TransportType.Amqp* in which case port 5671
      is used.

      If the port 5671 is unavailable/blocked in the network environment, *TransportType.AmqpOverWebsocket*
      could

      be used instead which uses port 443 for communication.'
    types:
    - <xref:azure.eventhub.TransportType>
  - name: http_proxy
    description: 'HTTP proxy settings. This must be a dictionary with the following

      keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

      Additionally the following keys may also be present: *''username'', ''password''*.'
    types:
    - <xref:Dict>
  - name: checkpoint_store
    description: 'A manager that stores the partition load-balancing and checkpoint
      data

      when receiving events. The checkpoint store will be used in both cases of receiving
      from all partitions

      or a single partition. In the latter case load-balancing does not apply.

      If a checkpoint store is not provided, the checkpoint will be maintained internally

      in memory, and the *EventHubConsumerClient* instance will receive events without
      load-balancing.'
    types:
    - <xref:Optional>[<xref:azure.eventhub.CheckpointStore>]
  - name: load_balancing_interval
    description: 'When load-balancing kicks in. This is the interval, in seconds,

      between two load-balancing evaluations. Default is 30 seconds.'
    types:
    - <xref:float>
  - name: partition_ownership_expiration_interval
    description: 'A partition ownership will expire after this number

      of seconds. Every load-balancing evaluation will automatically extend the ownership
      expiration time.

      Default is 6 * load_balancing_interval, i.e. 180 seconds when using the default
      load_balancing_interval

      of 30 seconds.'
    types:
    - <xref:float>
  - name: load_balancing_strategy
    description: 'When load-balancing kicks in,

      it will use this strategy to claim and balance the partition ownership.

      Use "greedy" or *LoadBalancingStrategy.GREEDY* for the greedy strategy, which,
      for every

      load-balancing evaluation, will grab as many unclaimed partitions required to
      balance the load.

      Use "balanced" or *LoadBalancingStrategy.BALANCED* for the balanced strategy,
      which, for every load-balancing

      evaluation, claims only one partition that is not claimed by other *EventHubConsumerClient*.

      If all partitions of an EventHub are claimed by other *EventHubConsumerClient*
      and this client has claimed

      too few partitions, this client will steal one partition from other clients
      for every load-balancing

      evaluation regardless of the load balancing strategy.

      Greedy strategy is used by default.'
    types:
    - <xref:str>
    - <xref:azure.eventhub.LoadBalancingStrategy>
  - name: custom_endpoint_address
    description: 'The custom endpoint address to use for establishing a connection
      to

      the Event Hubs service, allowing network requests to be routed through any application
      gateways or

      other paths needed for the host environment. Default is None.

      The format would be like "sb://<custom_endpoint_hostname>:<custom_endpoint_port>".

      If port is not specified in the *custom_endpoint_address*, by default port 443
      will be used.'
    types:
    - <xref:Optional>[<xref:str>]
  - name: connection_verify
    description: 'Path to the custom CA_BUNDLE file of the SSL certificate which is
      used to

      authenticate the identity of the connection endpoint.

      Default is None in which case *certifi.where()* will be used.'
    types:
    - <xref:Optional>[<xref:str>]
  - name: uamqp_transport
    description: 'Whether to use the *uamqp* library as the underlying transport.
      The default value is

      False and the Pure Python AMQP library will be used as the underlying transport.'
    types:
    - <xref:bool>
examples:
- "Create a new instance of the EventHubConsumerClient.<!--[!code-python[Main](les\\\
  sync_samples\\sample_code_eventhub.py )]-->\n\n<!-- literal_block {\"ids\": [],\
  \ \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
  : \"D:\\\\a\\\\_work\\\\1\\\\s\\\\dist_temp\\\\85\\\\azure-eventhub-5.11.3\\\\samples\\\
  \\sync_samples\\\\sample_code_eventhub.py\", \"xml:space\": \"preserve\", \"force\"\
  : false, \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"\
  linenos\": false} -->\n\n````python\n\n   import os\n   from azure.eventhub import\
  \ EventHubConsumerClient, EventHubSharedKeyCredential\n\n   fully_qualified_namespace\
  \ = os.environ['EVENT_HUB_HOSTNAME']\n   eventhub_name = os.environ['EVENT_HUB_NAME']\n\
  \   shared_access_policy = os.environ['EVENT_HUB_SAS_POLICY']\n   shared_access_key\
  \ = os.environ['EVENT_HUB_SAS_KEY']\n\n   credential = EventHubSharedKeyCredential(shared_access_policy,\
  \ shared_access_key)\n   consumer = EventHubConsumerClient(\n       fully_qualified_namespace=fully_qualified_namespace,\n\
  \       eventhub_name=eventhub_name,\n       consumer_group='$Default',\n      \
  \ credential=credential)\n\n   ````\n"
methods:
- uid: azure.eventhub.EventHubConsumerClient.close
  name: close
  summary: Stop retrieving events from the Event Hub and close the underlying AMQP
    connection and links.
  signature: close() -> None
  return:
    types:
    - <xref:None>
  examples:
  - "Close down the client.<!--[!code-python[Main](les\\sync_samples\\sample_code_eventhub.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\\_work\\\\1\\\\s\\\\\
    dist_temp\\\\85\\\\azure-eventhub-5.11.3\\\\samples\\\\sync_samples\\\\sample_code_eventhub.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n   import os\n   import threading\n\n   event_hub_connection_str = os.environ['EVENT_HUB_CONN_STR']\n\
    \   eventhub_name = os.environ['EVENT_HUB_NAME']\n\n   from azure.eventhub import\
    \ EventHubConsumerClient\n   consumer = EventHubConsumerClient.from_connection_string(\n\
    \       conn_str=event_hub_connection_str,\n       consumer_group=\"$Default\"\
    ,\n       eventhub_name=eventhub_name  # EventHub name should be specified if\
    \ it doesn't show up in connection string.\n   )\n\n   logger = logging.getLogger(\"\
    azure.eventhub\")\n\n   def on_event(partition_context, event):\n       # Put\
    \ your code here.\n       # If the operation is i/o intensive, multi-thread will\
    \ have better performance.\n       logger.info(\"Received event from partition:\
    \ {}\".format(partition_context.partition_id))\n\n   # The 'receive' method is\
    \ a blocking call, it can be executed in a thread for\n   # non-blocking behavior,\
    \ and combined with the 'close' method.\n\n   worker = threading.Thread(\n   \
    \    target=consumer.receive,\n       kwargs={\n           \"on_event\": on_event,\n\
    \           \"starting_position\": \"-1\",  # \"-1\" is from the beginning of\
    \ the partition.\n       }\n   )\n   worker.start()\n   time.sleep(10)  # Keep\
    \ receiving for 10s then close.\n   # Close down the consumer handler explicitly.\n\
    \   consumer.close()\n\n   ````\n"
- uid: azure.eventhub.EventHubConsumerClient.from_connection_string
  name: from_connection_string
  summary: Create an EventHubConsumerClient from a connection string.
  signature: 'from_connection_string(conn_str: str, consumer_group: str, **kwargs:
    Any) -> EventHubConsumerClient'
  parameters:
  - name: conn_str
    description: The connection string of an Event Hub.
    isRequired: true
    types:
    - <xref:str>
  - name: consumer_group
    description: Receive events from the Event Hub for this consumer group.
    isRequired: true
    types:
    - <xref:str>
  - name: eventhub_name
    description: The path of the specific Event Hub to connect the client to.
    types:
    - <xref:str>
  - name: logging_enable
    description: Whether to output network trace logs to the logger. Default is *False*.
    types:
    - <xref:bool>
  - name: auth_timeout
    description: 'The time in seconds to wait for a token to be authorized by the
      service.

      The default value is 60 seconds. If set to 0, no timeout will be enforced from
      the client.'
    types:
    - <xref:float>
  - name: user_agent
    description: If specified, this will be added in front of the user agent string.
    types:
    - <xref:str>
  - name: retry_total
    description: 'The total number of attempts to redo a failed operation when an
      error occurs.

      Default value is 3. The context of *retry_total* in receiving is special: The
      *receive* method is implemented

      by a while-loop calling internal receive method in each iteration. In the *receive*
      case,

      *retry_total* specifies the numbers of retry after error raised by internal
      receive method in the while-loop.

      If retry attempts are exhausted, the *on_error* callback will be called (if
      provided) with the error

      information. The failed internal partition consumer will be closed (*on_partition_close*
      will be called

      if provided) and new internal partition consumer will be created (*on_partition_initialize*
      will be called if

      provided) to resume receiving.'
    types:
    - <xref:int>
  - name: retry_backoff_factor
    description: 'A backoff factor to apply between attempts after the second try

      (most errors are resolved immediately by a second try without a delay).

      In fixed mode, retry policy will always sleep for {backoff factor}.

      In ''exponential'' mode, retry policy will sleep for: *{backoff factor} * (2
      ** ({number of total retries} - 1))*

      seconds. If the backoff_factor is 0.1, then the retry will sleep

      for [0.0s, 0.2s, 0.4s, ...] between retries. The default value is 0.8.'
    types:
    - <xref:float>
  - name: retry_backoff_max
    description: The maximum back off time. Default value is 120 seconds (2 minutes).
    types:
    - <xref:float>
  - name: retry_mode
    description: 'The delay behavior between retry attempts. Supported values are
      ''fixed'' or ''exponential'',

      where default is ''exponential''.'
    types:
    - <xref:str>
  - name: idle_timeout
    description: 'Timeout, in seconds, after which this client will close the underlying
      connection

      if there is no furthur activity. By default the value is None, meaning that
      the client will not shutdown due

      to inactivity unless initiated by the service.'
    types:
    - <xref:float>
  - name: transport_type
    description: 'The type of transport protocol that will be used for communicating
      with

      the Event Hubs service. Default is *TransportType.Amqp* in which case port 5671
      is used.

      If the port 5671 is unavailable/blocked in the network environment, *TransportType.AmqpOverWebsocket*
      could

      be used instead which uses port 443 for communication.'
    types:
    - <xref:azure.eventhub.TransportType>
  - name: http_proxy
    description: 'HTTP proxy settings. This must be a dictionary with the following

      keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

      Additionally the following keys may also be present: *''username'', ''password''*.'
    types:
    - <xref:Dict>
  - name: checkpoint_store
    description: 'A manager that stores the partition load-balancing and checkpoint
      data

      when receiving events. The checkpoint store will be used in both cases of receiving
      from all partitions

      or a single partition. In the latter case load-balancing does not apply.

      If a checkpoint store is not provided, the checkpoint will be maintained internally

      in memory, and the *EventHubConsumerClient* instance will receive events without
      load-balancing.'
    types:
    - <xref:Optional>[<xref:azure.eventhub.CheckpointStore>]
  - name: load_balancing_interval
    description: 'When load-balancing kicks in. This is the interval, in seconds,

      between two load-balancing evaluations. Default is 10 seconds.'
    types:
    - <xref:float>
  - name: partition_ownership_expiration_interval
    description: 'A partition ownership will expire after this number

      of seconds. Every load-balancing evaluation will automatically extend the ownership
      expiration time.

      Default is 6 * load_balancing_interval, i.e. 60 seconds when using the default
      load_balancing_interval

      of 30 seconds.'
    types:
    - <xref:float>
  - name: load_balancing_strategy
    description: 'When load-balancing kicks in,

      it will use this strategy to claim and balance the partition ownership.

      Use "greedy" or *LoadBalancingStrategy.GREEDY* for the greedy strategy, which,
      for every

      load-balancing evaluation, will grab as many unclaimed partitions required to
      balance the load.

      Use "balanced" or *LoadBalancingStrategy.BALANCED* for the balanced strategy,
      which, for every load-balancing

      evaluation, claims only one partition that is not claimed by other *EventHubConsumerClient*.

      If all partitions of an EventHub are claimed by other *EventHubConsumerClient*
      and this client has claimed

      too few partitions, this client will steal one partition from other clients
      for every load-balancing

      evaluation regardless of the load balancing strategy.

      Greedy strategy is used by default.'
    types:
    - <xref:str>
    - <xref:azure.eventhub.LoadBalancingStrategy>
  - name: custom_endpoint_address
    description: 'The custom endpoint address to use for establishing a connection
      to

      the Event Hubs service, allowing network requests to be routed through any application
      gateways or

      other paths needed for the host environment. Default is None.

      The format would be like "sb://<custom_endpoint_hostname>:<custom_endpoint_port>".

      If port is not specified in the *custom_endpoint_address*, by default port 443
      will be used.'
    types:
    - <xref:Optional>[<xref:str>]
  - name: connection_verify
    description: 'Path to the custom CA_BUNDLE file of the SSL certificate which is
      used to

      authenticate the identity of the connection endpoint.

      Default is None in which case *certifi.where()* will be used.'
    types:
    - <xref:Optional>[<xref:str>]
  - name: uamqp_transport
    description: 'Whether to use the *uamqp* library as the underlying transport.
      The default value is

      False and the Pure Python AMQP library will be used as the underlying transport.'
    types:
    - <xref:bool>
  return:
    types:
    - <xref:azure.eventhub.EventHubConsumerClient>
  examples:
  - "Create a new instance of the EventHubConsumerClient from connection string.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_eventhub.py )]-->\n\n<!-- literal_block {\"ids\": [],\
    \ \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\_work\\\\1\\\\s\\\\dist_temp\\\\85\\\\azure-eventhub-5.11.3\\\\\
    samples\\\\sync_samples\\\\sample_code_eventhub.py\", \"xml:space\": \"preserve\"\
    , \"force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\"\
    : 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.eventhub\
    \ import EventHubConsumerClient\n   event_hub_connection_str = os.environ['EVENT_HUB_CONN_STR']\n\
    \   eventhub_name = os.environ['EVENT_HUB_NAME']\n   consumer = EventHubConsumerClient.from_connection_string(\n\
    \       conn_str=event_hub_connection_str,\n       consumer_group='$Default',\n\
    \       eventhub_name=eventhub_name  # EventHub name should be specified if it\
    \ doesn't show up in connection string.\n   )\n\n   ````\n"
- uid: azure.eventhub.EventHubConsumerClient.get_eventhub_properties
  name: get_eventhub_properties
  summary: "Get properties of the Event Hub.\n\nKeys in the returned dictionary include:\n\
    \n   * *eventhub_name* (str) \n\n   * *created_at* (UTC datetime.datetime) \n\n\
    \   * *partition_ids* (list[str])"
  signature: get_eventhub_properties() -> Dict[str, Any]
  return:
    types:
    - <xref:Dict>[<xref:str>, <xref:Any>]
  exceptions:
  - type: azure.eventhub.exceptions.EventHubError
- uid: azure.eventhub.EventHubConsumerClient.get_partition_ids
  name: get_partition_ids
  summary: Get partition IDs of the Event Hub.
  signature: get_partition_ids() -> List[str]
  return:
    types:
    - <xref:list>[<xref:str>]
  exceptions:
  - type: azure.eventhub.exceptions.EventHubError
- uid: azure.eventhub.EventHubConsumerClient.get_partition_properties
  name: get_partition_properties
  summary: "Get properties of the specified partition.\n\nKeys in the properties dictionary\
    \ include:\n\n   * *eventhub_name* (str) \n\n   * *id* (str) \n\n   * *beginning_sequence_number*\
    \ (int) \n\n   * *last_enqueued_sequence_number* (int) \n\n   * *last_enqueued_offset*\
    \ (str) \n\n   * *last_enqueued_time_utc* (UTC datetime.datetime) \n\n   * *is_empty*\
    \ (bool)"
  signature: 'get_partition_properties(partition_id: str) -> Dict[str, Any]'
  parameters:
  - name: partition_id
    description: The target partition ID.
    isRequired: true
    types:
    - <xref:str>
  return:
    types:
    - <xref:Dict>[<xref:str>, <xref:Any>]
  exceptions:
  - type: azure.eventhub.exceptions.EventHubError
- uid: azure.eventhub.EventHubConsumerClient.receive
  name: receive
  summary: Receive events from partition(s), with optional load-balancing and checkpointing.
  signature: 'receive(on_event: Callable[[''PartitionContext'', ''EventData'' | None],
    None], **kwargs: Any) -> None'
  parameters:
  - name: on_event
    description: 'The callback function for handling a received event. The callback
      takes two

      parameters: *partition_context* which contains partition context and *event*
      which is the received event.

      The callback function should be defined like: *on_event(partition_context, event)*.

      For detailed partition context information, please refer to

      <xref:azure.eventhub.PartitionContext>.'
    isRequired: true
    types:
    - <xref:Callable>[<xref:azure.eventhub.PartitionContext>, <xref:Optional>[<xref:azure.eventhub.EventData>]]
  - name: max_wait_time
    description: 'The maximum interval in seconds that the event processor will wait
      before calling

      the callback. If no events are received within this interval, the *on_event*
      callback will be called with

      *None*.

      If this value is set to *None* or 0 (the default), the callback will not be
      called until an event is received.'
    types:
    - <xref:float>
  - name: partition_id
    description: 'If specified, the client will receive from this partition only.

      Otherwise the client will receive from all partitions.'
    types:
    - <xref:str>
  - name: owner_level
    description: 'The priority for an exclusive consumer. An exclusive

      consumer will be created if owner_level is set. A consumer with a higher owner_level
      has higher exclusive

      priority. The owner level is also know as the ''epoch value'' of the consumer.'
    types:
    - <xref:int>
  - name: prefetch
    description: 'The number of events to prefetch from the service

      for processing. Default is 300.'
    types:
    - <xref:int>
  - name: track_last_enqueued_event_properties
    description: 'Indicates whether the consumer should request information

      on the last-enqueued event on its associated partition, and track that information
      as events are received.

      When information about the partitions last-enqueued event is being tracked,
      each event received from the

      Event Hubs service will carry metadata about the partition. This results in
      a small amount of additional

      network bandwidth consumption that is generally a favorable trade-off when considered
      against periodically

      making requests for partition properties using the Event Hub client.

      It is set to *False* by default.'
    types:
    - <xref:bool>
  - name: starting_position
    description: 'Start receiving from this event position

      if there is no checkpoint data for a partition. Checkpoint data will be used
      if available. This can be a

      a dict with partition ID as the key and position as the value for individual
      partitions, or a single

      value for all partitions. The value type can be str, int or datetime.datetime.
      Also supported are the

      values "-1" for receiving from the beginning of the stream, and "@latest" for
      receiving only new events.

      Default value is "@latest".'
    types:
    - <xref:str>, <xref:int>, <xref:datetime.datetime>
    - <xref:Dict>[<xref:str,Any>]
  - name: starting_position_inclusive
    description: 'Determine whether the given starting_position is inclusive(>=) or

      not (>). True for inclusive and False for exclusive. This can be a dict with
      partition ID as the key and

      bool as the value indicating whether the starting_position for a specific partition
      is inclusive or not.

      This can also be a single bool value for all starting_position. The default
      value is False.'
    types:
    - <xref:bool>
    - <xref:Dict>[<xref:str,bool>]
  - name: on_error
    description: 'The callback function that will be called when an error is raised
      during receiving

      after retry attempts are exhausted, or during the process of load-balancing.

      The callback takes two parameters: *partition_context* which contains partition
      information

      and *error* being the exception. *partition_context* could be None if the error
      is raised during

      the process of load-balance. The callback should be defined like: *on_error(partition_context,
      error)*.

      The *on_error* callback will also be called if an unhandled exception is raised
      during

      the *on_event* callback.'
    types:
    - <xref:Callable>[[<xref:azure.eventhub.PartitionContext>, <xref:Exception>]]
  - name: on_partition_initialize
    description: 'The callback function that will be called after a consumer for a
      certain

      partition finishes initialization. It would also be called when a new internal
      partition consumer is created

      to take over the receiving process for a failed and closed internal partition
      consumer.

      The callback takes a single parameter: *partition_context*

      which contains the partition information. The callback should be defined

      like: *on_partition_initialize(partition_context)*.'
    types:
    - <xref:Callable>[[<xref:azure.eventhub.PartitionContext>]]
  - name: on_partition_close
    description: 'The callback function that will be called after a consumer for a
      certain

      partition is closed. It would be also called when error is raised during receiving
      after retry attempts are

      exhausted. The callback takes two parameters: *partition_context* which contains
      partition

      information and *reason* for the close. The callback should be defined like:

      *on_partition_close(partition_context, reason)*.

      Please refer to <xref:azure.eventhub.CloseReason> for the various closing reasons.'
    types:
    - <xref:Callable>[[<xref:azure.eventhub.PartitionContext>, <xref:azure.eventhub.CloseReason>]]
  return:
    types:
    - <xref:None>
  examples:
  - "Receive events from the EventHub.<!--[!code-python[Main](les\\sync_samples\\\
    sample_code_eventhub.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\_work\\\\1\\\\s\\\\dist_temp\\\\85\\\\azure-eventhub-5.11.3\\\\samples\\\\\
    sync_samples\\\\sample_code_eventhub.py\", \"xml:space\": \"preserve\", \"force\"\
    : false, \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"\
    linenos\": false} -->\n\n````python\n\n       logger = logging.getLogger(\"azure.eventhub\"\
    )\n\n       def on_event(partition_context, event):\n           # Put your code\
    \ here.\n           # If the operation is i/o intensive, multi-thread will have\
    \ better performance.\n           logger.info(\"Received event from partition:\
    \ {}\".format(partition_context.partition_id))\n\n       with consumer:\n    \
    \       consumer.receive(on_event=on_event)\n\n   ````\n"
- uid: azure.eventhub.EventHubConsumerClient.receive_batch
  name: receive_batch
  summary: Receive events from partition(s), with optional load-balancing and checkpointing.
  signature: 'receive_batch(on_event_batch: Callable[[''PartitionContext'', List[''EventData'']],
    None], **kwargs: Any) -> None'
  parameters:
  - name: on_event_batch
    description: 'The callback function for handling a batch of received events. The
      callback takes two

      parameters: *partition_context* which contains partition context and *event_batch*,
      which is the received

      events. The callback function should be defined like: *on_event_batch(partition_context,
      event_batch)*.

      *event_batch* could be an empty list if *max_wait_time* is not None nor 0 and
      no event is received

      after *max_wait_time*.

      For detailed partition context information, please refer to

      <xref:azure.eventhub.PartitionContext>.'
    isRequired: true
    types:
    - <xref:Callable>[<xref:azure.eventhub.PartitionContext>, <xref:List>[<xref:azure.eventhub.EventData>]]
  - name: max_batch_size
    description: 'The maximum number of events in a batch passed to callback *on_event_batch*.

      If the actual received number of events is larger than *max_batch_size*, the
      received events are divided into

      batches and call the callback for each batch with up to *max_batch_size* events.'
    types:
    - <xref:int>
  - name: max_wait_time
    description: 'The maximum interval in seconds that the event processor will wait
      before

      calling the callback.

      If no events are received within this interval, the *on_event_batch* callback
      will be called

      with an empty list.'
    types:
    - <xref:float>
  - name: partition_id
    description: 'If specified, the client will receive from this partition only.

      Otherwise the client will receive from all partitions.'
    types:
    - <xref:str>
  - name: owner_level
    description: 'The priority for an exclusive consumer. An exclusive

      consumer will be created if owner_level is set. A consumer with a higher owner_level
      has higher exclusive

      priority. The owner level is also know as the ''epoch value'' of the consumer.'
    types:
    - <xref:int>
  - name: prefetch
    description: 'The number of events to prefetch from the service

      for processing. Default is 300.'
    types:
    - <xref:int>
  - name: track_last_enqueued_event_properties
    description: 'Indicates whether the consumer should request information

      on the last-enqueued event on its associated partition, and track that information
      as events are received.

      When information about the partitions last-enqueued event is being tracked,
      each event received from the

      Event Hubs service will carry metadata about the partition. This results in
      a small amount of additional

      network bandwidth consumption that is generally a favorable trade-off when considered
      against periodically

      making requests for partition properties using the Event Hub client.

      It is set to *False* by default.'
    types:
    - <xref:bool>
  - name: starting_position
    description: 'Start receiving from this event position

      if there is no checkpoint data for a partition. Checkpoint data will be used
      if available. This can be a

      a dict with partition ID as the key and position as the value for individual
      partitions, or a single

      value for all partitions. The value type can be str, int or datetime.datetime.
      Also supported are the

      values "-1" for receiving from the beginning of the stream, and "@latest" for
      receiving only new events.

      Default value is "@latest".'
    types:
    - <xref:str>, <xref:int>, <xref:datetime.datetime>
    - <xref:Dict>[<xref:str,Any>]
  - name: starting_position_inclusive
    description: 'Determine whether the given starting_position is inclusive(>=) or

      not (>). True for inclusive and False for exclusive. This can be a dict with
      partition ID as the key and

      bool as the value indicating whether the starting_position for a specific partition
      is inclusive or not.

      This can also be a single bool value for all starting_position. The default
      value is False.'
    types:
    - <xref:bool>
    - <xref:Dict>[<xref:str,bool>]
  - name: on_error
    description: 'The callback function that will be called when an error is raised
      during receiving

      after retry attempts are exhausted, or during the process of load-balancing.

      The callback takes two parameters: *partition_context* which contains partition
      information

      and *error* being the exception. *partition_context* could be None if the error
      is raised during

      the process of load-balance. The callback should be defined like: *on_error(partition_context,
      error)*.

      The *on_error* callback will also be called if an unhandled exception is raised
      during

      the *on_event* callback.'
    types:
    - <xref:Callable>[[<xref:azure.eventhub.PartitionContext>, <xref:Exception>]]
  - name: on_partition_initialize
    description: 'The callback function that will be called after a consumer for a
      certain

      partition finishes initialization. It would also be called when a new internal
      partition consumer is created

      to take over the receiving process for a failed and closed internal partition
      consumer.

      The callback takes a single parameter: *partition_context*

      which contains the partition information. The callback should be defined

      like: *on_partition_initialize(partition_context)*.'
    types:
    - <xref:Callable>[[<xref:azure.eventhub.PartitionContext>]]
  - name: on_partition_close
    description: 'The callback function that will be called after a consumer for a
      certain

      partition is closed. It would be also called when error is raised during receiving
      after retry attempts are

      exhausted. The callback takes two parameters: *partition_context* which contains
      partition

      information and *reason* for the close. The callback should be defined like:

      *on_partition_close(partition_context, reason)*.

      Please refer to <xref:azure.eventhub.CloseReason> for the various closing reasons.'
    types:
    - <xref:Callable>[[<xref:azure.eventhub.PartitionContext>, <xref:azure.eventhub.CloseReason>]]
  return:
    types:
    - <xref:None>
  examples:
  - "Receive events in batches from the EventHub.<!--[!code-python[Main](les\\sync_samples\\\
    sample_code_eventhub.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\_work\\\\1\\\\s\\\\dist_temp\\\\85\\\\azure-eventhub-5.11.3\\\\samples\\\\\
    sync_samples\\\\sample_code_eventhub.py\", \"xml:space\": \"preserve\", \"force\"\
    : false, \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"\
    linenos\": false} -->\n\n````python\n\n       logger = logging.getLogger(\"azure.eventhub\"\
    )\n\n       def on_event_batch(partition_context, event_batch):\n           #\
    \ Put your code here.\n           # If the operation is i/o intensive, multi-thread\
    \ will have better performance.\n           logger.info(\"Received events from\
    \ partition: {}\".format(partition_context.partition_id))\n\n       with consumer:\n\
    \           consumer.receive_batch(on_event_batch=on_event_batch)\n\n   ````\n"
