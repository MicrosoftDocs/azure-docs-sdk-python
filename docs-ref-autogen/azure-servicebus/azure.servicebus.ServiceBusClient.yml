### YamlMime:PythonClass
uid: azure.servicebus.ServiceBusClient
name: ServiceBusClient
fullName: azure.servicebus.ServiceBusClient
module: azure.servicebus
inheritances:
- builtins.object
summary: 'The ServiceBusClient class defines a high level interface for

  getting ServiceBusSender and ServiceBusReceiver.'
constructor:
  syntax: 'ServiceBusClient(fully_qualified_namespace: str, credential: Union[TokenCredential,
    AzureSasCredential, AzureNamedKeyCredential], **kwargs: Any)'
  parameters:
  - name: fully_qualified_namespace
    description: 'The fully qualified host name for the Service Bus namespace.

      The namespace format is: *<yournamespace>.servicebus.windows.net*.'
    isRequired: true
    types:
    - <xref:str>
  - name: credential
    description: 'The credential object used for authentication which

      implements a particular interface for getting tokens. It accepts

      credential objects generated by the azure-identity library and objects that
      implement the

      *get_token(self, *scopes)* method, or alternatively, an AzureSasCredential can
      be provided too.'
    isRequired: true
    types:
    - <xref:azure.core.credentials.TokenCredential>
    - <xref:azure.core.credentials.AzureSasCredential>
    - <xref:azure.core.credentials.AzureNamedKeyCredential>
  - name: logging_enable
    description: Whether to output network trace logs to the logger. Default is *False*.
    types:
    - <xref:bool>
  - name: transport_type
    description: 'The type of transport protocol that will be used for communicating
      with

      the Service Bus service. Default is *TransportType.Amqp* in which case port
      5671 is used.

      If the port 5671 is unavailable/blocked in the network environment, *TransportType.AmqpOverWebsocket*
      could

      be used instead which uses port 443 for communication.'
    types:
    - <xref:azure.servicebus.TransportType>
  - name: http_proxy
    description: 'HTTP proxy settings. This must be a dictionary with the following

      keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

      Additionally the following keys may also be present: *''username'', ''password''*.'
    types:
    - <xref:dict>
  - name: user_agent
    description: If specified, this will be added in front of the built-in user agent
      string.
    types:
    - <xref:str>
  - name: retry_total
    description: 'The total number of attempts to redo a failed operation when an
      error occurs.

      Default value is 3.'
    types:
    - <xref:int>
  - name: retry_backoff_factor
    description: 'Delta back-off internal in the unit of second between retries.

      Default value is 0.8.'
    types:
    - <xref:float>
  - name: retry_backoff_max
    description: Maximum back-off interval in the unit of second. Default value is
      120.
    types:
    - <xref:float>
variables:
- description: 'The fully qualified host name for the Service Bus namespace.

    The namespace format is: *<yournamespace>.servicebus.windows.net*.'
  name: fully_qualified_namespace
  types:
  - <xref:str>
examples:
- "Create a new instance of the ServiceBusClient.<!--[!code-python[Main](les\\sync_samples\\\
  sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
  : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\
  \\1\\\\s\\\\dist_temp\\\\63\\\\azure-servicebus-7.4.0\\\\samples\\\\sync_samples\\\
  \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false, \"\
  language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\": false}\
  \ -->\n\n````python\n\n   import os\n   from azure.identity import DefaultAzureCredential\n\
  \   from azure.servicebus import ServiceBusClient\n   fully_qualified_namespace\
  \ = os.environ['SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE']\n   servicebus_client =\
  \ ServiceBusClient(\n       fully_qualified_namespace=fully_qualified_namespace,\n\
  \       credential=DefaultAzureCredential()\n   )\n\n   ````\n"
methods:
- uid: azure.servicebus.ServiceBusClient.close
  name: close
  summary: 'Close down the ServiceBus client.

    All spawned senders, receivers and underlying connection will be shutdown.'
  signature: close() -> None
  return:
    description: None
- uid: azure.servicebus.ServiceBusClient.from_connection_string
  name: from_connection_string
  summary: Create a ServiceBusClient from a connection string.
  signature: 'from_connection_string(conn_str: str, **kwargs: Any) -> azure.servicebus._servicebus_client.ServiceBusClient'
  parameters:
  - name: conn_str
    description: The connection string of a Service Bus.
    isRequired: true
    types:
    - <xref:str>
  - name: logging_enable
    description: Whether to output network trace logs to the logger. Default is *False*.
    types:
    - <xref:bool>
  - name: transport_type
    description: 'The type of transport protocol that will be used for communicating
      with

      the Service Bus service. Default is *TransportType.Amqp* in which case port
      5671 is used.

      If the port 5671 is unavailable/blocked in the network environment, *TransportType.AmqpOverWebsocket*
      could

      be used instead which uses port 443 for communication.'
    types:
    - <xref:azure.servicebus.TransportType>
  - name: http_proxy
    description: 'HTTP proxy settings. This must be a dictionary with the following

      keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

      Additionally the following keys may also be present: *''username'', ''password''*.'
    types:
    - <xref:dict>
  - name: user_agent
    description: If specified, this will be added in front of the built-in user agent
      string.
    types:
    - <xref:str>
  - name: retry_total
    description: 'The total number of attempts to redo a failed operation when an
      error occurs.

      Default value is 3.'
    types:
    - <xref:int>
  - name: retry_backoff_factor
    description: 'Delta back-off internal in the unit of second between retries.

      Default value is 0.8.'
    types:
    - <xref:float>
  - name: retry_backoff_max
    description: Maximum back-off interval in the unit of second. Default value is
      120.
    types:
    - <xref:float>
  return:
    types:
    - <xref:azure.servicebus.ServiceBusClient>
  examples:
  - "Create a new instance of the ServiceBusClient from connection string.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\63\\\\azure-servicebus-7.4.0\\\\samples\\\
    \\sync_samples\\\\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"\
    force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\"\
    : 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.servicebus\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   servicebus_client = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusClient.get_queue_receiver
  name: get_queue_receiver
  summary: Get ServiceBusReceiver for the specific queue.
  signature: 'get_queue_receiver(queue_name: str, **kwargs: Any) -> azure.servicebus._servicebus_receiver.ServiceBusReceiver'
  parameters:
  - name: queue_name
    description: The path of specific Service Bus Queue the client connects to.
    isRequired: true
    types:
    - <xref:str>
  - name: session_id
    description: 'A specific session from which to receive. This must be specified
      for a

      sessionful queue, otherwise it must be None. In order to receive messages from
      the next available

      session, set this to ~azure.servicebus.NEXT_AVAILABLE_SESSION.'
    types:
    - <xref:Union>[<xref:str>, <xref:azure.servicebus.NEXT_AVAILABLE_SESSION>]
  - name: str]] sub_queue
    description: 'If specified, the subqueue this receiver will

      connect to.

      This includes the DEAD_LETTER and TRANSFER_DEAD_LETTER queues, holds messages
      that can''t be delivered to any

      receiver or messages that can''t be processed.

      The default is None, meaning connect to the primary queue.  Can be assigned
      values from *ServiceBusSubQueue*

      enum or equivalent string values "deadletter" and "transferdeadletter".'
    types:
    - <xref:Optional>[<xref:Union>[<xref:azure.servicebus.ServiceBusSubQueue,>
  - name: receive_mode
    description: 'The receive_mode with which messages will be retrieved from the
      entity. The two options

      are PEEK_LOCK and RECEIVE_AND_DELETE. Messages received with PEEK_LOCK must
      be settled within a given

      lock period before they will be removed from the queue. Messages received with
      RECEIVE_AND_DELETE

      will be immediately removed from the queue, and cannot be subsequently rejected
      or re-received if

      the client fails to process the message. The default receive_mode is PEEK_LOCK.'
    types:
    - <xref:Union>[<xref:azure.servicebus.ServiceBusReceiveMode>, <xref:str>]
  - name: max_wait_time
    description: 'The timeout in seconds between received messages after which the

      receiver will automatically stop receiving. The default value is None, meaning
      no timeout.'
    types:
    - <xref:Optional>[<xref:float>]
  - name: auto_lock_renewer
    description: 'An ~azure.servicebus.AutoLockRenewer

      can be provided such that messages are automatically registered on receipt.
      If the receiver is a session

      receiver, it will apply to the session instead.'
    types:
    - <xref:Optional>[<xref:azure.servicebus.AutoLockRenewer>]
  - name: prefetch_count
    description: 'The maximum number of messages to cache with each request to the
      service.

      This setting is only for advanced performance tuning. Increasing this value
      will improve message throughput

      performance but increase the chance that messages will expire while they are
      cached if they''re not

      processed fast enough.

      The default value is 0, meaning messages will be received from the service and
      processed one at a time.

      In the case of prefetch_count being 0, *ServiceBusReceiver.receive* would try
      to cache *max_message_count*

      (if provided) within its request to the service.'
    types:
    - <xref:int>
  return:
    types:
    - <xref:azure.servicebus.ServiceBusReceiver>
  examples:
  - "Create a new instance of the ServiceBusReceiver from ServiceBusClient.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\63\\\\azure-servicebus-7.4.0\\\\samples\\\
    \\sync_samples\\\\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"\
    force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\"\
    : 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.servicebus\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   queue_name = os.environ['SERVICE_BUS_QUEUE_NAME']\n   servicebus_client =\
    \ ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   with servicebus_client:\n       queue_receiver = servicebus_client.get_queue_receiver(queue_name=queue_name)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusClient.get_queue_sender
  name: get_queue_sender
  summary: Get ServiceBusSender for the specific queue.
  signature: 'get_queue_sender(queue_name: str, **kwargs: Any) -> azure.servicebus._servicebus_sender.ServiceBusSender'
  parameters:
  - name: queue_name
    description: The path of specific Service Bus Queue the client connects to.
    isRequired: true
    types:
    - <xref:str>
  return:
    types:
    - <xref:azure.servicebus.ServiceBusSender>
  examples:
  - "Create a new instance of the ServiceBusSender from ServiceBusClient.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\63\\\\azure-servicebus-7.4.0\\\\samples\\\
    \\sync_samples\\\\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"\
    force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\"\
    : 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.servicebus\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   queue_name = os.environ['SERVICE_BUS_QUEUE_NAME']\n   servicebus_client =\
    \ ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   with servicebus_client:\n       queue_sender = servicebus_client.get_queue_sender(queue_name=queue_name)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusClient.get_subscription_receiver
  name: get_subscription_receiver
  summary: Get ServiceBusReceiver for the specific subscription under the topic.
  signature: 'get_subscription_receiver(topic_name: str, subscription_name: str, **kwargs:
    Any) -> azure.servicebus._servicebus_receiver.ServiceBusReceiver'
  parameters:
  - name: topic_name
    description: The name of specific Service Bus Topic the client connects to.
    isRequired: true
    types:
    - <xref:str>
  - name: subscription_name
    description: 'The name of specific Service Bus Subscription

      under the given Service Bus Topic.'
    isRequired: true
    types:
    - <xref:str>
  - name: session_id
    description: 'A specific session from which to receive. This must be specified
      for a

      sessionful subscription, otherwise it must be None. In order to receive messages
      from the next available

      session, set this to ~azure.servicebus.NEXT_AVAILABLE_SESSION.'
    types:
    - <xref:Union>[<xref:str>, <xref:azure.servicebus.NEXT_AVAILABLE_SESSION>]
  - name: str]] sub_queue
    description: 'If specified, the subqueue this receiver will

      connect to.

      This includes the DEAD_LETTER and TRANSFER_DEAD_LETTER queues, holds messages
      that can''t be delivered to any

      receiver or messages that can''t be processed.

      The default is None, meaning connect to the primary queue.  Can be assigned
      values from *ServiceBusSubQueue*

      enum or equivalent string values "deadletter" and "transferdeadletter".'
    types:
    - <xref:Optional>[<xref:Union>[<xref:azure.servicebus.ServiceBusSubQueue,>
  - name: receive_mode
    description: 'The receive_mode with which messages will be retrieved from the
      entity. The two options

      are PEEK_LOCK and RECEIVE_AND_DELETE. Messages received with PEEK_LOCK must
      be settled within a given

      lock period before they will be removed from the subscription. Messages received
      with RECEIVE_AND_DELETE

      will be immediately removed from the subscription, and cannot be subsequently
      rejected or re-received if

      the client fails to process the message. The default receive_mode is PEEK_LOCK.'
    types:
    - <xref:Union>[<xref:azure.servicebus.ServiceBusReceiveMode>, <xref:str>]
  - name: max_wait_time
    description: 'The timeout in seconds between received messages after which the

      receiver will automatically stop receiving. The default value is None, meaning
      no timeout.'
    types:
    - <xref:Optional>[<xref:float>]
  - name: auto_lock_renewer
    description: 'An ~azure.servicebus.AutoLockRenewer

      can be provided such that messages are automatically registered on receipt.
      If the receiver is a session

      receiver, it will apply to the session instead.'
    types:
    - <xref:Optional>[<xref:azure.servicebus.AutoLockRenewer>]
  - name: prefetch_count
    description: 'The maximum number of messages to cache with each request to the
      service.

      This setting is only for advanced performance tuning. Increasing this value
      will improve message throughput

      performance but increase the chance that messages will expire while they are
      cached if they''re not

      processed fast enough.

      The default value is 0, meaning messages will be received from the service and
      processed one at a time.

      In the case of prefetch_count being 0, *ServiceBusReceiver.receive* would try
      to cache *max_message_count*

      (if provided) within its request to the service.'
    types:
    - <xref:int>
  return:
    types:
    - <xref:azure.servicebus.ServiceBusReceiver>
  examples:
  - "Create a new instance of the ServiceBusReceiver from ServiceBusClient.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\63\\\\azure-servicebus-7.4.0\\\\samples\\\
    \\sync_samples\\\\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"\
    force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\"\
    : 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.servicebus\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   topic_name = os.environ[\"SERVICE_BUS_TOPIC_NAME\"]\n   subscription_name\
    \ = os.environ[\"SERVICE_BUS_SUBSCRIPTION_NAME\"]\n   servicebus_client = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   with servicebus_client:\n       subscription_receiver = servicebus_client.get_subscription_receiver(\n\
    \           topic_name=topic_name,\n           subscription_name=subscription_name,\n\
    \       )\n\n   ````\n"
- uid: azure.servicebus.ServiceBusClient.get_topic_sender
  name: get_topic_sender
  summary: Get ServiceBusSender for the specific topic.
  signature: 'get_topic_sender(topic_name: str, **kwargs: Any) -> azure.servicebus._servicebus_sender.ServiceBusSender'
  parameters:
  - name: topic_name
    description: The path of specific Service Bus Topic the client connects to.
    isRequired: true
    types:
    - <xref:str>
  return:
    types:
    - <xref:azure.servicebus.ServiceBusSender>
  examples:
  - "Create a new instance of the ServiceBusSender from ServiceBusClient.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\63\\\\azure-servicebus-7.4.0\\\\samples\\\
    \\sync_samples\\\\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"\
    force\": false, \"language\": \"python\", \"highlight_args\": {\"linenostart\"\
    : 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n   from azure.servicebus\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   topic_name = os.environ['SERVICE_BUS_TOPIC_NAME']\n   servicebus_client =\
    \ ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   with servicebus_client:\n       topic_sender = servicebus_client.get_topic_sender(topic_name=topic_name)\n\
    \n   ````\n"
