### YamlMime:PythonClass
uid: azure.servicebus.aio.ServiceBusReceiver
name: ServiceBusReceiver
fullName: azure.servicebus.aio.ServiceBusReceiver
module: azure.servicebus.aio
inheritances:
- collections.abc.AsyncIterator
- azure.servicebus.aio._base_handler_async.BaseHandler
- azure.servicebus._common.receiver_mixins.ReceiverMixin
summary: 'The ServiceBusReceiver class defines a high level interface for

  receiving messages from the Azure Service Bus Queue or Topic Subscription.


  The two primary channels for message receipt are *receive()* to make a single request
  for messages,

  and *async for message in receiver:* to continuously receive incoming messages in
  an ongoing fashion.


  Please use the *get_<queue/subscription>_receiver* method of ~azure.servicebus.aio.ServiceBusClient
  to create a

  ServiceBusReceiver instance.'
constructor:
  syntax: 'ServiceBusReceiver(fully_qualified_namespace: str, credential: AsyncTokenCredential
    | AzureSasCredential | AzureNamedKeyCredential, *, queue_name: str | None = None,
    topic_name: str | None = None, subscription_name: str | None = None, receive_mode:
    ServiceBusReceiveMode | str = ServiceBusReceiveMode.PEEK_LOCK, max_wait_time:
    float | None = None, auto_lock_renewer: AutoLockRenewer | None = None, prefetch_count:
    int = 0, **kwargs: Any)'
  parameters:
  - name: fully_qualified_namespace
    description: 'The fully qualified host name for the Service Bus namespace.

      The namespace format is: *<yournamespace>.servicebus.windows.net*.'
    isRequired: true
    types:
    - <xref:str>
  - name: credential
    description: 'The credential object used for authentication which

      implements a particular interface for getting tokens. It accepts

      credential objects generated by the azure-identity library and objects that
      implement the

      *get_token(self, *scopes)* method, or alternatively, an AzureSasCredential can
      be provided too.'
    isRequired: true
    types:
    - <xref:azure.core.credentials_async.AsyncTokenCredential>
    - <xref:azure.core.credentials.AzureSasCredential>
    - <xref:azure.core.credentials.AzureNamedKeyCredential>
  keywordOnlyParameters:
  - name: queue_name
    description: The path of specific Service Bus Queue the client connects to.
    types:
    - <xref:str>
  - name: topic_name
    description: 'The path of specific Service Bus Topic which contains the Subscription

      the client connects to.'
    types:
    - <xref:str>
  - name: subscription_name
    description: 'The path of specific Service Bus Subscription under the

      specified Topic the client connects to.'
    types:
    - <xref:str>
  - name: receive_mode
    description: 'The mode with which messages will be retrieved from the entity.
      The two options

      are PEEK_LOCK and RECEIVE_AND_DELETE. Messages received with PEEK_LOCK must
      be settled within a given

      lock period before they will be removed from the queue. Messages received with
      RECEIVE_AND_DELETE

      will be immediately removed from the queue, and cannot be subsequently abandoned
      or re-received

      if the client fails to process the message.

      The default mode is PEEK_LOCK.'
    defaultValue: ServiceBusReceiveMode.PEEK_LOCK
    types:
    - <xref:typing.Union>[<xref:azure.servicebus.ServiceBusReceiveMode>, <xref:str>]
  - name: max_wait_time
    description: 'The timeout in seconds to wait for the first and subsequent

      messages to arrive. If no messages arrive, and no timeout is specified, this
      call will not return

      until the connection is closed. The default value is None, meaning no timeout.
      On a sessionful

      queue/topic when NEXT_AVAILABLE_SESSION is specified, this will act as the timeout
      for connecting

      to a session. If connection errors are occurring due to write timing out,the
      connection timeout

      value may need to be adjusted. See the *socket_timeout* optional parameter for
      more details.'
    types:
    - <xref:typing.Optional>[<xref:float>]
  - name: logging_enable
    description: Whether to output network trace logs to the logger. Default is *False*.
    types:
    - <xref:bool>
  - name: transport_type
    description: 'The type of transport protocol that will be used for communicating
      with

      the Service Bus service. Default is *TransportType.Amqp*.'
    types:
    - <xref:azure.servicebus.TransportType>
  - name: http_proxy
    description: 'HTTP proxy settings. This must be a dictionary with the following

      keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

      Additionally the following keys may also be present: *''username'', ''password''*.'
    types:
    - <xref:typing.Dict>
  - name: user_agent
    description: If specified, this will be added in front of the built-in user agent
      string.
    types:
    - <xref:str>
  - name: auto_lock_renewer
    description: 'An ~azure.servicebus.aio.AutoLockRenewer

      can be provided such that messages are automatically registered on receipt.
      If the receiver is a session receiver,

      it will apply to the session instead.'
    types:
    - <xref:typing.Optional>[<xref:azure.servicebus.aio.AutoLockRenewer>]
  - name: prefetch_count
    description: 'The maximum number of messages to cache with each request to the
      service.

      This setting is only for advanced performance tuning. Increasing this value
      will improve message throughput

      performance but increase the chance that messages will expire while they are
      cached if they''re not

      processed fast enough.

      The default value is 0, meaning messages will be received from the service and
      processed one at a time.

      In the case of prefetch_count being 0, *ServiceBusReceiver.receive_messages*
      would try to cache

      *max_message_count* (if provided) within its request to the service.

      WARNING: If prefetch_count > 0 and RECEIVE_AND_DELETE mode is used, all prefetched
      messages will stay in

      the in-memory prefetch buffer until they''re received into the application.
      If the application ends before

      the messages are received into the application, those messages will be lost
      and unable to be recovered.

      Therefore, it''s recommended that PEEK_LOCK mode be used with prefetch.'
    types:
    - <xref:int>
  - name: client_identifier
    description: 'A string-based identifier to uniquely identify the client instance.

      Service Bus will associate it with some error messages for easier correlation
      of errors. If not specified,

      a unique id will be generated.'
    types:
    - <xref:str>
  - name: socket_timeout
    description: 'The time in seconds that the underlying socket on the connection
      should

      wait when sending and receiving data before timing out. The default value is
      0.2 for TransportType.Amqp

      and 1 for TransportType.AmqpOverWebsocket. If connection errors are occurring
      due to write timing out,

      a larger than default value may need to be passed in.'
    types:
    - <xref:float>
variables:
- description: 'The fully qualified host name for the Service Bus namespace.

    The namespace format is: *<yournamespace>.servicebus.windows.net*.'
  name: fully_qualified_namespace
  types:
  - <xref:str>
- description: The path of the entity that the client connects to.
  name: entity_path
  types:
  - <xref:str>
methods:
- uid: azure.servicebus.aio.ServiceBusReceiver.abandon_message
  name: abandon_message
  summary: 'Abandon the message.


    This message will be returned to the queue and made available to be received again.'
  signature: 'async abandon_message(message: ServiceBusReceivedMessage) -> None'
  parameters:
  - name: message
    description: The received message to be abandoned.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  return:
    types:
    - <xref:None>
  exceptions:
  - type: azure.servicebus.exceptions.MessageAlreadySettled if the message has been
      settled.
  - type: azure.servicebus.exceptions.SessionLockLostError if session lock has already
      expired.
  - type: azure.servicebus.exceptions.ServiceBusError when errors happen.
  examples:
  - "Abandon a received message.<!--[!code-python[Main](les\\async_samples\\sample_code_servicebus_async.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\hostedtoolcache\\\\windows\\\
    \\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\\py2docfx\\\\dist_temp\\\\\
    211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\async_samples\\\\sample_code_servicebus_async.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       messages = await servicebus_receiver.receive_messages(max_wait_time=5)\n\
    \       for message in messages:\n           await servicebus_receiver.abandon_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusReceiver.close
  name: close
  signature: async close() -> None
- uid: azure.servicebus.aio.ServiceBusReceiver.complete_message
  name: complete_message
  summary: 'Complete the message.


    This removes the message from the queue.'
  signature: 'async complete_message(message: ServiceBusReceivedMessage) -> None'
  parameters:
  - name: message
    description: The received message to be completed.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  return:
    types:
    - <xref:None>
  exceptions:
  - type: azure.servicebus.exceptions.MessageAlreadySettled if the message has been
      settled.
  - type: azure.servicebus.exceptions.SessionLockLostError if session lock has already
      expired.
  - type: azure.servicebus.exceptions.ServiceBusError when errors happen.
  examples:
  - "Complete a received message.<!--[!code-python[Main](les\\async_samples\\sample_code_servicebus_async.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\hostedtoolcache\\\\windows\\\
    \\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\\py2docfx\\\\dist_temp\\\\\
    211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\async_samples\\\\sample_code_servicebus_async.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       messages = await servicebus_receiver.receive_messages(max_wait_time=5)\n\
    \       for message in messages:\n           await servicebus_receiver.complete_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusReceiver.dead_letter_message
  name: dead_letter_message
  summary: 'Move the message to the Dead Letter queue.


    The Dead Letter queue is a sub-queue that can be

    used to store messages that failed to process correctly, or otherwise require
    further inspection

    or processing. The queue can also be configured to send expired messages to the
    Dead Letter queue.'
  signature: 'async dead_letter_message(message: ServiceBusReceivedMessage, reason:
    str | None = None, error_description: str | None = None) -> None'
  parameters:
  - name: message
    description: The received message to be dead-lettered.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  - name: reason
    description: The reason for dead-lettering the message.
    defaultValue: None
    types:
    - <xref:typing.Optional>[<xref:str>]
  - name: error_description
    description: The detailed error description for dead-lettering the message.
    defaultValue: None
    types:
    - <xref:typing.Optional>[<xref:str>]
  return:
    types:
    - <xref:None>
  exceptions:
  - type: azure.servicebus.exceptions.MessageAlreadySettled if the message has been
      settled.
  - type: azure.servicebus.exceptions.SessionLockLostError if session lock has already
      expired.
  - type: azure.servicebus.exceptions.ServiceBusError when errors happen.
  examples:
  - "Dead letter a received message.<!--[!code-python[Main](les\\async_samples\\sample_code_servicebus_async.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\hostedtoolcache\\\\windows\\\
    \\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\\py2docfx\\\\dist_temp\\\\\
    211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\async_samples\\\\sample_code_servicebus_async.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       messages = await servicebus_receiver.receive_messages(max_wait_time=5)\n\
    \       for message in messages:\n           await servicebus_receiver.dead_letter_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusReceiver.defer_message
  name: defer_message
  summary: 'Defers the message.


    This message will remain in the queue but must be requested

    specifically by its sequence number in order to be received.'
  signature: 'async defer_message(message: ServiceBusReceivedMessage) -> None'
  parameters:
  - name: message
    description: The received message to be deferred.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  return:
    types:
    - <xref:None>
  exceptions:
  - type: azure.servicebus.exceptions.MessageAlreadySettled if the message has been
      settled.
  - type: azure.servicebus.exceptions.SessionLockLostError if session lock has already
      expired.
  - type: azure.servicebus.exceptions.ServiceBusError when errors happen.
  examples:
  - "Defer a received message.<!--[!code-python[Main](les\\async_samples\\sample_code_servicebus_async.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\hostedtoolcache\\\\windows\\\
    \\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\\py2docfx\\\\dist_temp\\\\\
    211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\async_samples\\\\sample_code_servicebus_async.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       messages = await servicebus_receiver.receive_messages(max_wait_time=5)\n\
    \       for message in messages:\n           await servicebus_receiver.defer_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusReceiver.delete_messages
  name: delete_messages
  summary: This operation deletes messages in the queue that are older than the specified
    enqueued time.
  signature: 'async delete_messages(*, max_message_count: int | None = None, before:
    datetime | None = None, timeout: float | None = None) -> int'
  keywordOnlyParameters:
  - name: max_message_count
    description: 'The maximum number of messages to delete. The default value is None,

      meaning it will attempt to delete up to 4,000 messages.'
    types:
    - <xref:int>
    - <xref:None>
  - name: before
    description: 'The UTC datetime value before which all messages

      should be deleted. The default value is None, meaning all messages in the queue
      will be considered.'
    types:
    - <xref:datetime.datetime>
    - <xref:None>
  - name: timeout
    description: 'The total operation timeout in seconds including all the retries.

      The value must be greater than 0 if specified. The default value is None, meaning
      no timeout.'
    types:
    - <xref:typing.Optional>[<xref:float>]
  return:
    description: The number of deleted messages.
    types:
    - <xref:int>
- uid: azure.servicebus.aio.ServiceBusReceiver.peek_messages
  name: peek_messages
  summary: 'Browse messages currently pending in the queue.


    Peeked messages are not removed from queue, nor are they locked. They cannot be
    completed,

    deferred or dead-lettered.'
  signature: 'async peek_messages(max_message_count: int = 1, *, sequence_number:
    int = 0, timeout: float | None = None, **kwargs: Any) -> List[ServiceBusReceivedMessage]'
  parameters:
  - name: max_message_count
    description: 'The maximum number of messages to try and peek. The default

      value is 1.'
    defaultValue: '1'
    types:
    - <xref:int>
  keywordOnlyParameters:
  - name: sequence_number
    description: A message sequence number from which to start browsing messages.
    types:
    - <xref:int>
  - name: timeout
    description: 'The total operation timeout in seconds including all the retries.

      The value must be greater than 0 if specified. The default value is None, meaning
      no timeout.'
    types:
    - <xref:typing.Optional>[<xref:float>]
  return:
    description: A list of ~azure.servicebus.ServiceBusReceivedMessage objects.
    types:
    - <xref:list>[<xref:azure.servicebus.ServiceBusReceivedMessage>]
  examples:
  - "Peek messages in the queue.<!--[!code-python[Main](les\\async_samples\\sample_code_servicebus_async.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\hostedtoolcache\\\\windows\\\
    \\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\\py2docfx\\\\dist_temp\\\\\
    211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\async_samples\\\\sample_code_servicebus_async.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n   async with servicebus_receiver:\n       messages = await servicebus_receiver.peek_messages()\n\
    \       for message in messages:\n           print(str(message))\n\n   ````\n"
- uid: azure.servicebus.aio.ServiceBusReceiver.purge_messages
  name: purge_messages
  summary: This operation purges as many messages as possible in the queue that are
    older than the specified enqueued time.
  signature: 'async purge_messages(*, before: datetime | None = None, timeout: float
    | None = None) -> int'
  keywordOnlyParameters:
  - name: before
    description: 'The UTC datetime value before which all messages

      should be deleted. The default value is None, meaning all messages from the
      current time and before

      in the queue will be considered.'
    types:
    - <xref:datetime.datetime>
    - <xref:None>
  - name: timeout
    description: 'The total operation timeout in seconds including all the retries.

      The value must be greater than 0 if specified. The default value is None, meaning
      no timeout.'
    types:
    - <xref:typing.Optional>[<xref:float>]
  return:
    description: The number of deleted messages.
    types:
    - <xref:int>
- uid: azure.servicebus.aio.ServiceBusReceiver.receive_deferred_messages
  name: receive_deferred_messages
  summary: 'Receive messages that have previously been deferred.


    When receiving deferred messages from a partitioned entity, all of the supplied

    sequence numbers must be messages from the same partition.'
  signature: 'async receive_deferred_messages(sequence_numbers: int | List[int], *,
    timeout: float | None = None, **kwargs: Any) -> List[ServiceBusReceivedMessage]'
  parameters:
  - name: sequence_numbers
    description: 'A list of the sequence numbers of messages that have been

      deferred.'
    isRequired: true
    types:
    - <xref:typing.Union>[<xref:int>, <xref:list>[<xref:int>]]
  keywordOnlyParameters:
  - name: timeout
    description: 'The total operation timeout in seconds including all the retries.

      The value must be greater than 0 if specified. The default value is None, meaning
      no timeout.'
    types:
    - <xref:typing.Optional>[<xref:float>]
  return:
    description: A list of the received messages.
    types:
    - <xref:list>[<xref:azure.servicebus.ServiceBusReceivedMessage>]
  examples:
  - "Receive deferred messages from ServiceBus.<!--[!code-python[Main](les\\async_samples\\\
    sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\\
    hostedtoolcache\\\\windows\\\\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\
    \\py2docfx\\\\dist_temp\\\\211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\async_samples\\\
    \\sample_code_servicebus_async.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   async with servicebus_receiver:\n       deferred_sequenced_numbers\
    \ = []\n       messages = await servicebus_receiver.receive_messages(max_wait_time=5)\n\
    \       for message in messages:\n           deferred_sequenced_numbers.append(message.sequence_number)\n\
    \           print(str(message))\n           await servicebus_receiver.defer_message(message)\n\
    \n       received_deferred_msg = await servicebus_receiver.receive_deferred_messages(\n\
    \           sequence_numbers=deferred_sequenced_numbers\n       )\n\n       for\
    \ message in received_deferred_msg:\n           await servicebus_receiver.complete_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusReceiver.receive_messages
  name: receive_messages
  summary: 'Receive a batch of messages at once.


    This approach is optimal if you wish to process multiple messages simultaneously,
    or

    perform an ad-hoc receive as a single call.


    Note that the number of messages retrieved in a single batch will be dependent
    on

    whether *prefetch_count* was set for the receiver. If *prefetch_count* is not
    set for the receiver,

    the receiver would try to cache max_message_count (if provided) messages within
    the request to the service.


    This call will prioritize returning quickly over meeting a specified batch size,
    and so will

    return as soon as at least one message is received and there is a gap in incoming
    messages regardless

    of the specified batch size.'
  signature: 'async receive_messages(max_message_count: int | None = 1, max_wait_time:
    float | None = None) -> List[ServiceBusReceivedMessage]'
  parameters:
  - name: max_message_count
    description: 'Maximum number of messages in the batch. Actual number

      returned will depend on prefetch_count size and incoming stream rate.

      Setting to None will fully depend on the prefetch config. The default value
      is 1.'
    defaultValue: '1'
    types:
    - <xref:typing.Optional>[<xref:int>]
  - name: max_wait_time
    description: 'Maximum time to wait in seconds for the first message to arrive.

      If no messages arrive, and no timeout is specified, this call will not return

      until the connection is closed. If specified, and no messages arrive within
      the

      timeout period, an empty list will be returned. NOTE: Setting max_wait_time
      on receive_messages

      when NEXT_AVAILABLE_SESSION is specified will not impact the timeout for connecting
      to a session.

      Please use max_wait_time on the constructor to set the timeout for connecting
      to a session.'
    defaultValue: None
    types:
    - <xref:typing.Optional>[<xref:float>]
  return:
    description: A list of messages received. If no messages are available, this will
      be an empty list.
    types:
    - <xref:list>[<xref:azure.servicebus.ServiceBusReceivedMessage>]
  examples:
  - "Receive messages from ServiceBus.<!--[!code-python[Main](les\\async_samples\\\
    sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\\
    hostedtoolcache\\\\windows\\\\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\
    \\py2docfx\\\\dist_temp\\\\211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\async_samples\\\
    \\sample_code_servicebus_async.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   async with servicebus_receiver:\n       messages\
    \ = await servicebus_receiver.receive_messages(max_wait_time=5)\n       for message\
    \ in messages:\n           print(str(message))\n           await servicebus_receiver.complete_message(message)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusReceiver.renew_message_lock
  name: renew_message_lock
  summary: 'Renew the message lock.


    This will maintain the lock on the message to ensure it is not returned to the
    queue

    to be reprocessed.


    In order to complete (or otherwise settle) the message, the lock must be maintained,

    and cannot already have expired; an expired lock cannot be renewed.


    Messages received via RECEIVE_AND_DELETE mode are not locked, and therefore cannot
    be renewed.

    This operation is only available for non-sessionful messages as well.'
  signature: 'async renew_message_lock(message: ServiceBusReceivedMessage, *, timeout:
    float | None = None, **kwargs: Any) -> datetime'
  parameters:
  - name: message
    description: The message to renew the lock for.
    isRequired: true
    types:
    - <xref:azure.servicebus.ServiceBusReceivedMessage>
  keywordOnlyParameters:
  - name: timeout
    description: 'The total operation timeout in seconds including all the retries.

      The value must be greater than 0 if specified. The default value is None, meaning
      no timeout.'
    types:
    - <xref:typing.Optional>[<xref:float>]
  return:
    description: The utc datetime the lock is set to expire at.
    types:
    - <xref:datetime.datetime>
  exceptions:
  - type: TypeError if the message is sessionful.
  - type: azure.servicebus.exceptions.MessageAlreadySettled if the message has been
      settled.
  - type: azure.servicebus.exceptions.MessageLockLostError if message lock has already
      expired.
  examples:
  - "Renew the lock on a received message.<!--[!code-python[Main](les\\async_samples\\\
    sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\\
    hostedtoolcache\\\\windows\\\\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\
    \\py2docfx\\\\dist_temp\\\\211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\async_samples\\\
    \\sample_code_servicebus_async.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n       messages = await servicebus_receiver.receive_messages(max_wait_time=5)\n\
    \       for message in messages:\n           await servicebus_receiver.renew_message_lock(message)\n\
    \n   ````\n"
attributes:
- uid: azure.servicebus.aio.ServiceBusReceiver.client_identifier
  name: client_identifier
  summary: Get the ServiceBusReceiver client identifier associated with the receiver
    instance.
  return:
    types:
    - <xref:str>
- uid: azure.servicebus.aio.ServiceBusReceiver.session
  name: session
  summary: 'Get the ServiceBusSession object linked with the receiver. Session is
    only available to session-enabled

    entities, it would return None if called on a non-sessionful receiver.'
  return:
    types:
    - <xref:azure.servicebus.aio.ServiceBusSession>
  examples:
  - "Get session from a receiver<!--[!code-python[Main](les\\async_samples\\sample_code_servicebus_async.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\hostedtoolcache\\\\windows\\\
    \\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\\py2docfx\\\\dist_temp\\\\\
    211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\async_samples\\\\sample_code_servicebus_async.py\"\
    , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"\
    highlight_args\": {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\
    \n       async with servicebus_client.get_queue_receiver(queue_name=queue_name,\
    \ session_id=session_id) as receiver:\n           session = receiver.session\n\
    \n   ````\n"
