### YamlMime:PythonClass
uid: azure.servicebus.aio.ServiceBusClient
name: ServiceBusClient
fullName: azure.servicebus.aio.ServiceBusClient
module: azure.servicebus.aio
inheritances:
- builtins.object
summary: 'The ServiceBusClient class defines a high level interface for

  getting ServiceBusSender and ServiceBusReceiver.'
constructor:
  syntax: ServiceBusClient(fully_qualified_namespace, credential, **kwargs)
  parameters:
  - name: fully_qualified_namespace
    description: 'The fully qualified host name for the Service Bus namespace.

      The namespace format is: *<yournamespace>.servicebus.windows.net*.'
    types:
    - <xref:str>
  - name: credential
    description: 'The credential object used for authentication which

      implements a particular interface for getting tokens. It accepts

      credential objects generated by the azure-identity library and objects that
      implement the

      *get_token(self, *scopes)* method.'
    types:
    - <xref:azure.core.credentials.TokenCredential>
  - name: logging_enable
    description: Whether to output network trace logs to the logger. Default is *False*.
    types:
    - <xref:bool>
  - name: transport_type
    description: 'The type of transport protocol that will be used for communicating
      with

      the Service Bus service. Default is *TransportType.Amqp*.'
    types:
    - <xref:azure.servicebus.TransportType>
  - name: http_proxy
    description: 'HTTP proxy settings. This must be a dictionary with the following

      keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

      Additionally the following keys may also be present: *''username'', ''password''*.'
    types:
    - <xref:dict>
  - name: user_agent
    description: If specified, this will be added in front of the built-in user agent
      string.
    types:
    - <xref:str>
  - name: retry_total
    description: 'The total number of attempts to redo a failed operation when an
      error occurs.

      Default value is 3.'
    types:
    - <xref:int>
  - name: retry_backoff_factor
    description: 'Delta back-off internal in the unit of second between retries.

      Default value is 0.8.'
    types:
    - <xref:float>
  - name: retry_backoff_max
    description: Maximum back-off interval in the unit of second. Default value is
      120.
    types:
    - <xref:float>
variables:
- description: 'The fully qualified host name for the Service Bus namespace.

    The namespace format is: *<yournamespace>.servicebus.windows.net*.'
  name: fully_qualified_namespace
  types:
  - <xref:str>
examples:
- "Create a new instance of the ServiceBusClient.<!--[!code-python[Main](les\\async_samples\\\
  sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
  : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\
  \\1\\\\s\\\\dist_temp\\\\5\\\\azure-servicebus-7.0.0b7\\\\samples\\\\async_samples\\\
  \\sample_code_servicebus_async.py\", \"xml:space\": \"preserve\", \"language\":\
  \ \"python\", \"linenos\": false, \"highlight_args\": {\"linenostart\": 1}} -->\n\
  \n````python\n\n   import os\n   from azure.servicebus.aio import ServiceBusClient,\
  \ ServiceBusSharedKeyCredential\n   fully_qualified_namespace = os.environ['SERVICE_BUS_FULLY_QUALIFIED_NAMESPACE']\n\
  \   shared_access_policy = os.environ['SERVICE_BUS_SAS_POLICY']\n   shared_access_key\
  \ = os.environ['SERVICE_BUS_SAS_KEY']\n   servicebus_client = ServiceBusClient(\n\
  \       fully_qualified_namespace=fully_qualified_namespace,\n       credential=ServiceBusSharedKeyCredential(\n\
  \           shared_access_policy,\n           shared_access_key\n       )\n   )\n\
  \n   ````\n"
methods:
- uid: azure.servicebus.aio.ServiceBusClient.close
  name: close
  summary: 'Close down the ServiceBus client.

    All spawned senders, receivers and underlying connection will be shutdown.'
  signature: close()
  return:
    description: None
- uid: azure.servicebus.aio.ServiceBusClient.from_connection_string
  name: from_connection_string
  summary: Create a ServiceBusClient from a connection string.
  signature: from_connection_string(conn_str, **kwargs)
  parameters:
  - name: conn_str
    description: The connection string of a Service Bus.
    isRequired: true
    types:
    - <xref:str>
  - name: logging_enable
    description: Whether to output network trace logs to the logger. Default is *False*.
    isRequired: true
    types:
    - <xref:bool>
  - name: transport_type
    description: 'The type of transport protocol that will be used for communicating
      with

      the Service Bus service. Default is *TransportType.Amqp*.'
    isRequired: true
    types:
    - <xref:azure.servicebus.TransportType>
  - name: http_proxy
    description: 'HTTP proxy settings. This must be a dictionary with the following

      keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

      Additionally the following keys may also be present: *''username'', ''password''*.'
    isRequired: true
    types:
    - <xref:dict>
  - name: user_agent
    description: If specified, this will be added in front of the built-in user agent
      string.
    isRequired: true
    types:
    - <xref:str>
  - name: retry_total
    description: 'The total number of attempts to redo a failed operation when an
      error occurs.

      Default value is 3.'
    isRequired: true
    types:
    - <xref:int>
  - name: retry_backoff_factor
    description: 'Delta back-off internal in the unit of second between retries.

      Default value is 0.8.'
    isRequired: true
    types:
    - <xref:float>
  - name: retry_backoff_max
    description: Maximum back-off interval in the unit of second. Default value is
      120.
    isRequired: true
    types:
    - <xref:float>
  return:
    types:
    - <xref:azure.servicebus.aio.ServiceBusClient>
  examples:
  - "Create a new instance of the ServiceBusClient from connection string.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"\
    ids\": [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [],\
    \ \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\5\\\\azure-servicebus-7.0.0b7\\\
    \\samples\\\\async_samples\\\\sample_code_servicebus_async.py\", \"xml:space\"\
    : \"preserve\", \"language\": \"python\", \"linenos\": false, \"highlight_args\"\
    : {\"linenostart\": 1}} -->\n\n````python\n\n   import os\n   from azure.servicebus.aio\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   servicebus_client = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusClient.get_queue_receiver
  name: get_queue_receiver
  summary: Get ServiceBusReceiver for the specific queue.
  signature: get_queue_receiver(queue_name, **kwargs)
  parameters:
  - name: queue_name
    description: The path of specific Service Bus Queue the client connects to.
    isRequired: true
    types:
    - <xref:str>
  - name: sub_queue
    description: 'If specified, the subqueue this receiver will connect to.

      This includes the DeadLetter and TransferDeadLetter queues, holds messages that
      can''t be delivered to any

      receiver or messages that can''t be processed.  The default is None, meaning
      connect to the primary queue.'
    isRequired: true
    types:
    - <xref:Optional>[<xref:SubQueue>]
  - name: receive_mode
    description: 'The mode with which messages will be retrieved from the entity.
      The two options

      are PeekLock and ReceiveAndDelete. Messages received with PeekLock must be settled
      within a given

      lock period before they will be removed from the queue. Messages received with
      ReceiveAndDelete

      will be immediately removed from the queue, and cannot be subsequently rejected
      or re-received if

      the client fails to process the message. The default mode is PeekLock.'
    isRequired: true
    types:
    - <xref:azure.servicebus.ReceiveMode>
  - name: max_wait_time
    description: 'The timeout in seconds between received messages after which the
      receiver will

      automatically stop receiving. The default value is 0, meaning no timeout.'
    isRequired: true
    types:
    - <xref:float>
  - name: prefetch_count
    description: 'The maximum number of messages to cache with each request to the
      service.

      This setting is only for advanced performance tuning. Increasing this value
      will improve message throughput

      performance but increase the chance that messages will expire while they are
      cached if they''re not

      processed fast enough.

      The default value is 0, meaning messages will be received from the service and
      processed one at a time.

      In the case of prefetch_count being 0, *ServiceBusReceiver.receive* would try
      to cache *max_message_count*

      (if provided) within its request to the service.'
    isRequired: true
    types:
    - <xref:int>
  return:
    types:
    - <xref:azure.servicebus.aio.ServiceBusReceiver>
  examples:
  - "Create a new instance of the ServiceBusSender from ServiceBusClient.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"\
    ids\": [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [],\
    \ \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\5\\\\azure-servicebus-7.0.0b7\\\
    \\samples\\\\async_samples\\\\sample_code_servicebus_async.py\", \"xml:space\"\
    : \"preserve\", \"language\": \"python\", \"linenos\": false, \"highlight_args\"\
    : {\"linenostart\": 1}} -->\n\n````python\n\n   import os\n   from azure.servicebus.aio\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   queue_name = os.environ['SERVICE_BUS_QUEUE_NAME']\n   servicebus_client =\
    \ ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   async with servicebus_client:\n       queue_receiver = servicebus_client.get_queue_receiver(queue_name=queue_name)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusClient.get_queue_sender
  name: get_queue_sender
  summary: Get ServiceBusSender for the specific queue.
  signature: get_queue_sender(queue_name, **kwargs)
  parameters:
  - name: queue_name
    description: The path of specific Service Bus Queue the client connects to.
    isRequired: true
    types:
    - <xref:str>
  return:
    types:
    - <xref:azure.servicebus.aio.ServiceBusSender>
  examples:
  - "Create a new instance of the ServiceBusClient from connection string.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"\
    ids\": [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [],\
    \ \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\5\\\\azure-servicebus-7.0.0b7\\\
    \\samples\\\\async_samples\\\\sample_code_servicebus_async.py\", \"xml:space\"\
    : \"preserve\", \"language\": \"python\", \"linenos\": false, \"highlight_args\"\
    : {\"linenostart\": 1}} -->\n\n````python\n\n   import os\n   from azure.servicebus.aio\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   queue_name = os.environ['SERVICE_BUS_QUEUE_NAME']\n   servicebus_client =\
    \ ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   async with servicebus_client:\n       queue_sender = servicebus_client.get_queue_sender(queue_name=queue_name)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusClient.get_queue_session_receiver
  name: get_queue_session_receiver
  summary: Get ServiceBusSessionReceiver for the specific queue.
  signature: get_queue_session_receiver(queue_name, session_id=None, **kwargs)
  parameters:
  - name: queue_name
    description: The path of specific Service Bus Queue the client connects to.
    isRequired: true
    types:
    - <xref:str>
  - name: session_id
    description: 'A specific session from which to receive. This must be specified
      for a

      sessionful entity, otherwise it must be None. In order to receive messages from
      the next available

      session, set this to None.  The default is None.'
    defaultValue: None
    types:
    - <xref:str>
  - name: receive_mode
    description: 'The mode with which messages will be retrieved from the entity.
      The two options

      are PeekLock and ReceiveAndDelete. Messages received with PeekLock must be settled
      within a given

      lock period before they will be removed from the queue. Messages received with
      ReceiveAndDelete

      will be immediately removed from the queue, and cannot be subsequently rejected
      or re-received if

      the client fails to process the message. The default mode is PeekLock.'
    isRequired: true
    types:
    - <xref:azure.servicebus.ReceiveMode>
  - name: max_wait_time
    description: 'The timeout in seconds between received messages after which the
      receiver will

      automatically stop receiving. The default value is 0, meaning no timeout.'
    isRequired: true
    types:
    - <xref:float>
  - name: prefetch_count
    description: 'The maximum number of messages to cache with each request to the
      service.

      This setting is only for advanced performance tuning. Increasing this value
      will improve message throughput

      performance but increase the chance that messages will expire while they are
      cached if they''re not

      processed fast enough.

      The default value is 0, meaning messages will be received from the service and
      processed one at a time.

      In the case of prefetch_count being 0, *ServiceBusReceiver.receive* would try
      to cache *max_message_count*

      (if provided) within its request to the service.'
    isRequired: true
    types:
    - <xref:int>
  return:
    types:
    - <xref:azure.servicebus.aio.ServiceBusSessionReceiver>
  examples:
  - "Create a new instance of the ServiceBusSender from ServiceBusClient.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"\
    ids\": [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [],\
    \ \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\5\\\\azure-servicebus-7.0.0b7\\\
    \\samples\\\\async_samples\\\\sample_code_servicebus_async.py\", \"xml:space\"\
    : \"preserve\", \"language\": \"python\", \"linenos\": false, \"highlight_args\"\
    : {\"linenostart\": 1}} -->\n\n````python\n\n   import os\n   from azure.servicebus.aio\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   queue_name = os.environ['SERVICE_BUS_QUEUE_NAME']\n   servicebus_client =\
    \ ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   async with servicebus_client:\n       queue_sender = servicebus_client.get_queue_sender(queue_name=queue_name)\n\
    \n   ````\n"
- uid: azure.servicebus.aio.ServiceBusClient.get_subscription_receiver
  name: get_subscription_receiver
  summary: Get ServiceBusReceiver for the specific subscription under the topic.
  signature: get_subscription_receiver(topic_name, subscription_name, **kwargs)
  parameters:
  - name: topic_name
    description: The name of specific Service Bus Topic the client connects to.
    isRequired: true
    types:
    - <xref:str>
  - name: subscription_name
    description: 'The name of specific Service Bus Subscription

      under the given Service Bus Topic.'
    isRequired: true
    types:
    - <xref:str>
  - name: sub_queue
    description: 'If specified, the subqueue this receiver will connect to.

      This includes the DeadLetter and TransferDeadLetter queues, holds messages that
      can''t be delivered to any

      receiver or messages that can''t be processed.  The default is None, meaning
      connect to the primary queue.'
    isRequired: true
    types:
    - <xref:Optional>[<xref:SubQueue>]
  - name: receive_mode
    description: 'The mode with which messages will be retrieved from the entity.
      The two options

      are PeekLock and ReceiveAndDelete. Messages received with PeekLock must be settled
      within a given

      lock period before they will be removed from the subscription. Messages received
      with ReceiveAndDelete

      will be immediately removed from the subscription, and cannot be subsequently
      rejected or re-received if

      the client fails to process the message. The default mode is PeekLock.'
    isRequired: true
    types:
    - <xref:azure.servicebus.ReceiveMode>
  - name: max_wait_time
    description: 'The timeout in seconds between received messages after which the
      receiver will

      automatically stop receiving. The default value is 0, meaning no timeout.'
    isRequired: true
    types:
    - <xref:float>
  - name: prefetch_count
    description: 'The maximum number of messages to cache with each request to the
      service.

      This setting is only for advanced performance tuning. Increasing this value
      will improve message throughput

      performance but increase the chance that messages will expire while they are
      cached if they''re not

      processed fast enough.

      The default value is 0, meaning messages will be received from the service and
      processed one at a time.

      In the case of prefetch_count being 0, *ServiceBusReceiver.receive* would try
      to cache *max_message_count*

      (if provided) within its request to the service.'
    isRequired: true
    types:
    - <xref:int>
  return:
    types:
    - <xref:azure.servicebus.aio.ServiceBusReceiver>
  examples:
  - "Create a new instance of the ServiceBusReceiver from ServiceBusClient.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"\
    ids\": [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [],\
    \ \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\5\\\\azure-servicebus-7.0.0b7\\\
    \\samples\\\\async_samples\\\\sample_code_servicebus_async.py\", \"xml:space\"\
    : \"preserve\", \"language\": \"python\", \"linenos\": false, \"highlight_args\"\
    : {\"linenostart\": 1}} -->\n\n````python\n\n   import os\n   from azure.servicebus\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   topic_name = os.environ[\"SERVICE_BUS_TOPIC_NAME\"]\n   subscription_name\
    \ = os.environ[\"SERVICE_BUS_SUBSCRIPTION_NAME\"]\n   servicebus_client = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   async with servicebus_client:\n       subscription_receiver = servicebus_client.get_subscription_receiver(\n\
    \           topic_name=topic_name,\n           subscription_name=subscription_name,\n\
    \       )\n\n   ````\n"
- uid: azure.servicebus.aio.ServiceBusClient.get_subscription_session_receiver
  name: get_subscription_session_receiver
  summary: Get ServiceBusReceiver for the specific subscription under the topic.
  signature: get_subscription_session_receiver(topic_name, subscription_name, session_id=None,
    **kwargs)
  parameters:
  - name: topic_name
    description: The name of specific Service Bus Topic the client connects to.
    isRequired: true
    types:
    - <xref:str>
  - name: subscription_name
    description: 'The name of specific Service Bus Subscription

      under the given Service Bus Topic.'
    isRequired: true
    types:
    - <xref:str>
  - name: session_id
    description: 'A specific session from which to receive. This must be specified
      for a

      sessionful entity, otherwise it must be None. In order to receive messages from
      the next available

      session, set this to None.  The default is None.'
    defaultValue: None
    types:
    - <xref:str>
  - name: receive_mode
    description: 'The mode with which messages will be retrieved from the entity.
      The two options

      are PeekLock and ReceiveAndDelete. Messages received with PeekLock must be settled
      within a given

      lock period before they will be removed from the subscription. Messages received
      with ReceiveAndDelete

      will be immediately removed from the subscription, and cannot be subsequently
      rejected or re-received if

      the client fails to process the message. The default mode is PeekLock.'
    isRequired: true
    types:
    - <xref:azure.servicebus.ReceiveMode>
  - name: max_wait_time
    description: 'The timeout in seconds between received messages after which the
      receiver will

      automatically stop receiving. The default value is 0, meaning no timeout.'
    isRequired: true
    types:
    - <xref:float>
  - name: prefetch_count
    description: 'The maximum number of messages to cache with each request to the
      service.

      This setting is only for advanced performance tuning. Increasing this value
      will improve message throughput

      performance but increase the chance that messages will expire while they are
      cached if they''re not

      processed fast enough.

      The default value is 0, meaning messages will be received from the service and
      processed one at a time.

      In the case of prefetch_count being 0, *ServiceBusReceiver.receive* would try
      to cache *max_message_count*

      (if provided) within its request to the service.'
    isRequired: true
    types:
    - <xref:int>
  return:
    types:
    - <xref:azure.servicebus.aio.ServiceBusSessionReceiver>
  examples:
  - "Create a new instance of the ServiceBusReceiver from ServiceBusClient.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"\
    ids\": [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [],\
    \ \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\5\\\\azure-servicebus-7.0.0b7\\\
    \\samples\\\\async_samples\\\\sample_code_servicebus_async.py\", \"xml:space\"\
    : \"preserve\", \"language\": \"python\", \"linenos\": false, \"highlight_args\"\
    : {\"linenostart\": 1}} -->\n\n````python\n\n   import os\n   from azure.servicebus\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   topic_name = os.environ[\"SERVICE_BUS_TOPIC_NAME\"]\n   subscription_name\
    \ = os.environ[\"SERVICE_BUS_SUBSCRIPTION_NAME\"]\n   servicebus_client = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   async with servicebus_client:\n       subscription_receiver = servicebus_client.get_subscription_receiver(\n\
    \           topic_name=topic_name,\n           subscription_name=subscription_name,\n\
    \       )\n\n   ````\n"
- uid: azure.servicebus.aio.ServiceBusClient.get_topic_sender
  name: get_topic_sender
  summary: Get ServiceBusSender for the specific topic.
  signature: get_topic_sender(topic_name, **kwargs)
  parameters:
  - name: topic_name
    description: The path of specific Service Bus Topic the client connects to.
    isRequired: true
    types:
    - <xref:str>
  return:
    types:
    - <xref:azure.servicebus.aio.ServiceBusSender>
  examples:
  - "Create a new instance of the ServiceBusSender from ServiceBusClient.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_servicebus_async.py )]-->\n\n<!-- literal_block {\"\
    ids\": [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [],\
    \ \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\5\\\\azure-servicebus-7.0.0b7\\\
    \\samples\\\\async_samples\\\\sample_code_servicebus_async.py\", \"xml:space\"\
    : \"preserve\", \"language\": \"python\", \"linenos\": false, \"highlight_args\"\
    : {\"linenostart\": 1}} -->\n\n````python\n\n   import os\n   from azure.servicebus\
    \ import ServiceBusClient\n   servicebus_connection_str = os.environ['SERVICE_BUS_CONNECTION_STR']\n\
    \   topic_name = os.environ['SERVICE_BUS_TOPIC_NAME']\n   servicebus_client =\
    \ ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   async with servicebus_client:\n       topic_sender = servicebus_client.get_topic_sender(topic_name=topic_name)\n\
    \n   ````\n"
