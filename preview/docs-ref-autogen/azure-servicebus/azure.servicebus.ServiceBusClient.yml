### YamlMime:PythonClass
uid: azure.servicebus.ServiceBusClient
name: ServiceBusClient
fullName: azure.servicebus.ServiceBusClient
module: azure.servicebus
inheritances:
- builtins.object
summary: 'The ServiceBusClient class defines a high level interface for

  getting ServiceBusSender and ServiceBusReceiver.'
constructor:
  syntax: 'ServiceBusClient(fully_qualified_namespace: str, credential: TokenCredential
    | AzureSasCredential | AzureNamedKeyCredential, *, retry_total: int = 3, retry_backoff_factor:
    float = 0.8, retry_backoff_max: float = 120, retry_mode: str = ''exponential'',
    **kwargs: Any)'
  parameters:
  - name: fully_qualified_namespace
    description: 'The fully qualified host name for the Service Bus namespace.

      The namespace format is: *<yournamespace>.servicebus.windows.net*.'
    isRequired: true
    types:
    - <xref:str>
  - name: credential
    description: 'The credential object used for authentication which

      implements a particular interface for getting tokens. It accepts

      credential objects generated by the azure-identity library and objects that
      implement the

      *get_token(self, *scopes)* method, or alternatively, an AzureSasCredential can
      be provided too.'
    isRequired: true
    types:
    - <xref:azure.core.credentials.TokenCredential>
    - <xref:azure.core.credentials.AzureSasCredential>
    - <xref:azure.core.credentials.AzureNamedKeyCredential>
  keywordOnlyParameters:
  - name: logging_enable
    description: Whether to output network trace logs to the logger. Default is *False*.
    types:
    - <xref:bool>
  - name: transport_type
    description: 'The type of transport protocol that will be used for communicating
      with

      the Service Bus service. Default is *TransportType.Amqp* in which case port
      5671 is used.

      If the port 5671 is unavailable/blocked in the network environment, *TransportType.AmqpOverWebsocket*
      could

      be used instead which uses port 443 for communication.'
    types:
    - <xref:azure.servicebus.TransportType>
  - name: http_proxy
    description: 'HTTP proxy settings. This must be a dictionary with the following

      keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

      Additionally the following keys may also be present: *''username'', ''password''*.'
    types:
    - <xref:typing.Dict>
  - name: user_agent
    description: If specified, this will be added in front of the built-in user agent
      string.
    types:
    - <xref:str>
  - name: retry_total
    description: 'The total number of attempts to redo a failed operation when an
      error occurs.

      Default value is 3.'
    defaultValue: '3'
    types:
    - <xref:int>
  - name: retry_backoff_factor
    description: 'Delta back-off internal in the unit of second between retries.

      Default value is 0.8.'
    defaultValue: '0.8'
    types:
    - <xref:float>
  - name: retry_backoff_max
    description: Maximum back-off interval in the unit of second. Default value is
      120.
    defaultValue: '120'
    types:
    - <xref:float>
  - name: retry_mode
    description: 'The delay behavior between retry attempts. Supported values are
      "fixed" or "exponential",

      where default is "exponential".'
    defaultValue: exponential
    types:
    - <xref:str>
  - name: custom_endpoint_address
    description: 'The custom endpoint address to use for establishing a connection
      to

      the Service Bus service, allowing network requests to be routed through any
      application gateways or

      other paths needed for the host environment. Default is None.

      The format would be like "sb://<custom_endpoint_hostname>:<custom_endpoint_port>".

      If port is not specified in the *custom_endpoint_address*, by default port 443
      will be used.'
    types:
    - <xref:str>
  - name: connection_verify
    description: 'Path to the custom CA_BUNDLE file of the SSL certificate which is
      used to

      authenticate the identity of the connection endpoint.

      Default is None in which case *certifi.where()* will be used.'
    types:
    - <xref:str>
  - name: uamqp_transport
    description: 'Whether to use the *uamqp* library as the underlying transport.
      The default value is

      False and the Pure Python AMQP library will be used as the underlying transport.'
    types:
    - <xref:bool>
variables:
- description: 'The fully qualified host name for the Service Bus namespace.

    The namespace format is: *<yournamespace>.servicebus.windows.net*.'
  name: fully_qualified_namespace
  types:
  - <xref:str>
examples:
- "Create a new instance of the ServiceBusClient.<!--[!code-python[Main](les\\sync_samples\\\
  sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
  : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"C:\\\\hostedtoolcache\\\
  \\windows\\\\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\\py2docfx\\\\dist_temp\\\
  \\211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\sync_samples\\\\sample_code_servicebus.py\"\
  , \"xml:space\": \"preserve\", \"force\": false, \"language\": \"python\", \"highlight_args\"\
  : {\"linenostart\": 1}, \"linenos\": false} -->\n\n````python\n\n   import os\n\
  \   from azure.identity import DefaultAzureCredential\n   from azure.servicebus\
  \ import ServiceBusClient\n   fully_qualified_namespace = os.environ['SERVICEBUS_FULLY_QUALIFIED_NAMESPACE']\n\
  \   servicebus_client = ServiceBusClient(\n       fully_qualified_namespace=fully_qualified_namespace,\n\
  \       credential=DefaultAzureCredential()\n   )\n\n   ````\n"
methods:
- uid: azure.servicebus.ServiceBusClient.close
  name: close
  summary: 'Close down the ServiceBus client.

    All spawned senders, receivers and underlying connection will be shutdown.'
  signature: close() -> None
  return:
    description: None
- uid: azure.servicebus.ServiceBusClient.from_connection_string
  name: from_connection_string
  summary: Create a ServiceBusClient from a connection string.
  signature: 'from_connection_string(conn_str: str, *, retry_total: int = 3, retry_backoff_factor:
    float = 0.8, retry_backoff_max: float = 120, retry_mode: str = ''exponential'',
    **kwargs: Any) -> ServiceBusClient'
  parameters:
  - name: conn_str
    description: The connection string of a Service Bus.
    isRequired: true
    types:
    - <xref:str>
  keywordOnlyParameters:
  - name: logging_enable
    description: Whether to output network trace logs to the logger. Default is *False*.
    types:
    - <xref:bool>
  - name: transport_type
    description: 'The type of transport protocol that will be used for communicating
      with

      the Service Bus service. Default is *TransportType.Amqp* in which case port
      5671 is used.

      If the port 5671 is unavailable/blocked in the network environment, *TransportType.AmqpOverWebsocket*
      could

      be used instead which uses port 443 for communication.'
    types:
    - <xref:azure.servicebus.TransportType>
  - name: http_proxy
    description: 'HTTP proxy settings. This must be a dictionary with the following

      keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

      Additionally the following keys may also be present: *''username'', ''password''*.'
    types:
    - <xref:typing.Dict>
  - name: user_agent
    description: If specified, this will be added in front of the built-in user agent
      string.
    types:
    - <xref:str>
  - name: retry_total
    description: 'The total number of attempts to redo a failed operation when an
      error occurs.

      Default value is 3.'
    defaultValue: '3'
    types:
    - <xref:int>
  - name: retry_backoff_factor
    description: 'Delta back-off internal in the unit of second between retries.

      Default value is 0.8.'
    defaultValue: '0.8'
    types:
    - <xref:float>
  - name: retry_backoff_max
    description: Maximum back-off interval in the unit of second. Default value is
      120.
    defaultValue: '120'
    types:
    - <xref:float>
  - name: retry_mode
    description: 'The delay behavior between retry attempts. Supported values are
      ''fixed'' or ''exponential'',

      where default is ''exponential''.'
    defaultValue: exponential
    types:
    - <xref:str>
  - name: custom_endpoint_address
    description: 'The custom endpoint address to use for establishing a connection
      to

      the Service Bus service, allowing network requests to be routed through any
      application gateways or

      other paths needed for the host environment. Default is None.

      The format would be like "sb://<custom_endpoint_hostname>:<custom_endpoint_port>".

      If port is not specified in the custom_endpoint_address, by default port 443
      will be used.'
    types:
    - <xref:str>
  - name: connection_verify
    description: 'Path to the custom CA_BUNDLE file of the SSL certificate which is
      used to

      authenticate the identity of the connection endpoint.

      Default is None in which case *certifi.where()* will be used.'
    types:
    - <xref:str>
  - name: uamqp_transport
    description: 'Whether to use the *uamqp* library as the underlying transport.
      The default value is

      False and the Pure Python AMQP library will be used as the underlying transport.'
    types:
    - <xref:bool>
  return:
    description: The ServiceBusClient instance.
    types:
    - <xref:azure.servicebus.ServiceBusClient>
  examples:
  - "Create a new instance of the ServiceBusClient from connection string.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\
    \\py2docfx\\\\dist_temp\\\\211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\sync_samples\\\
    \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   import os\n   from azure.servicebus import ServiceBusClient\n\
    \   servicebus_connection_str = os.environ['SERVICEBUS_CONNECTION_STR']\n   servicebus_client\
    \ = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusClient.get_queue_receiver
  name: get_queue_receiver
  summary: Get ServiceBusReceiver for the specific queue.
  signature: 'get_queue_receiver(queue_name: str, *, session_id: str | ~typing.Literal[<ServiceBusSessionFilter.NEXT_AVAILABLE:
    0>] | None = None, sub_queue: ~azure.servicebus._common.constants.ServiceBusSubQueue
    | str | None = None, receive_mode: ~azure.servicebus._common.constants.ServiceBusReceiveMode
    | str = ServiceBusReceiveMode.PEEK_LOCK, max_wait_time: float | None = None, auto_lock_renewer:
    ~azure.servicebus._common.auto_lock_renewer.AutoLockRenewer | None = None, prefetch_count:
    int = 0, **kwargs: ~typing.Any) -> ServiceBusReceiver'
  parameters:
  - name: queue_name
    description: The path of specific Service Bus Queue the client connects to.
    isRequired: true
    types:
    - <xref:str>
  keywordOnlyParameters:
  - name: session_id
    description: 'A specific session from which to receive. This must be specified
      for a

      sessionful queue, otherwise it must be None. In order to receive messages from
      the next available

      session, set this to ~azure.servicebus.NEXT_AVAILABLE_SESSION.'
    types:
    - <xref:str>
    - <xref:azure.servicebus.NEXT_AVAILABLE_SESSION>
  - name: sub_queue
    description: 'If specified, the subqueue this receiver will connect to.

      This includes the DEAD_LETTER and TRANSFER_DEAD_LETTER queues, holds messages
      that can''t be delivered to any

      receiver or messages that can''t be processed.

      The default is None, meaning connect to the primary queue.  Can be assigned
      values from *ServiceBusSubQueue*

      enum or equivalent string values "deadletter" and "transferdeadletter".'
    types:
    - <xref:str>
    - <xref:azure.servicebus.ServiceBusSubQueue>
    - <xref:None>
  - name: receive_mode
    description: 'The receive_mode with which messages will be retrieved from the
      entity. The two options

      are PEEK_LOCK and RECEIVE_AND_DELETE. Messages received with PEEK_LOCK must
      be settled within a given

      lock period before they will be removed from the queue. Messages received with
      RECEIVE_AND_DELETE

      will be immediately removed from the queue, and cannot be subsequently rejected
      or re-received if

      the client fails to process the message. The default receive_mode is PEEK_LOCK.'
    defaultValue: ServiceBusReceiveMode.PEEK_LOCK
    types:
    - <xref:typing.Union>[<xref:azure.servicebus.ServiceBusReceiveMode>, <xref:str>]
  - name: max_wait_time
    description: 'The timeout in seconds to wait for the first and subsequent

      messages to arrive. If no messages arrive, and no timeout is specified, this
      call will not return

      until the connection is closed. The default value is None, meaning no timeout.
      On a sessionful

      queue/topic when NEXT_AVAILABLE_SESSION is specified, this will act as the timeout
      for connecting.

      If connection errors are occurring due to write timing out,the connection timeout

      value may need to be adjusted. See the *socket_timeout* optional parameter for
      more details.'
    types:
    - <xref:typing.Optional>[<xref:float>]
  - name: auto_lock_renewer
    description: 'An ~azure.servicebus.AutoLockRenewer

      can be provided such that messages are automatically registered on receipt.
      If the receiver is a session

      receiver, it will apply to the session instead.'
    types:
    - <xref:typing.Optional>[<xref:azure.servicebus.AutoLockRenewer>]
  - name: prefetch_count
    description: 'The maximum number of messages to cache with each request to the
      service.

      This setting is only for advanced performance tuning. Increasing this value
      will improve message throughput

      performance but increase the chance that messages will expire while they are
      cached if they''re not

      processed fast enough.

      The default value is 0, meaning messages will be received from the service and
      processed one at a time.

      In the case of prefetch_count being 0, *ServiceBusReceiver.receive_messages*
      would try to cache

      *max_message_count* (if provided) within its request to the service.

      WARNING: If prefetch_count > 0 and RECEIVE_AND_DELETE mode is used, all prefetched
      messages will stay in

      the in-memory prefetch buffer until they''re received into the application.
      If the application ends before

      the messages are received into the application, those messages will be lost
      and unable to be recovered.

      Therefore, it''s recommended that PEEK_LOCK mode be used with prefetch.'
    types:
    - <xref:int>
  - name: client_identifier
    description: 'A string-based identifier to uniquely identify the receiver instance.

      Service Bus will associate it with some error messages for easier correlation
      of errors.

      If not specified, a unique id will be generated.'
    types:
    - <xref:str>
  - name: socket_timeout
    description: 'The time in seconds that the underlying socket on the connection
      should

      wait when sending and receiving data before timing out. The default value is
      0.2 for TransportType.Amqp

      and 1 for TransportType.AmqpOverWebsocket. If connection errors are occurring
      due to write timing out,

      a larger than default value may need to be passed in.'
    types:
    - <xref:float>
  return:
    description: The ServiceBusReceiver for the queue.
    types:
    - <xref:azure.servicebus.ServiceBusReceiver>
  examples:
  - "Create a new instance of the ServiceBusReceiver from ServiceBusClient.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\
    \\py2docfx\\\\dist_temp\\\\211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\sync_samples\\\
    \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   import os\n   from azure.servicebus import ServiceBusClient\n\
    \   servicebus_connection_str = os.environ['SERVICEBUS_CONNECTION_STR']\n   queue_name\
    \ = os.environ['SERVICEBUS_QUEUE_NAME']\n   servicebus_client = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   with servicebus_client:\n       queue_receiver = servicebus_client.get_queue_receiver(queue_name=queue_name)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusClient.get_queue_sender
  name: get_queue_sender
  summary: Get ServiceBusSender for the specific queue.
  signature: 'get_queue_sender(queue_name: str, **kwargs: Any) -> ServiceBusSender'
  parameters:
  - name: queue_name
    description: The path of specific Service Bus Queue the client connects to.
    isRequired: true
    types:
    - <xref:str>
  keywordOnlyParameters:
  - name: client_identifier
    description: 'A string-based identifier to uniquely identify the sender instance.

      Service Bus will associate it with some error messages for easier correlation
      of errors.

      If not specified, a unique id will be generated.'
    types:
    - <xref:str>
  - name: socket_timeout
    description: 'The time in seconds that the underlying socket on the connection
      should

      wait when sending and receiving data before timing out. The default value is
      0.2 for TransportType.Amqp

      and 1 for TransportType.AmqpOverWebsocket. If connection errors are occurring
      due to write timing out,

      a larger than default value may need to be passed in.'
    types:
    - <xref:float>
  return:
    description: A queue Sender.
    types:
    - <xref:azure.servicebus.ServiceBusSender>
  examples:
  - "Create a new instance of the ServiceBusSender from ServiceBusClient.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\
    \\py2docfx\\\\dist_temp\\\\211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\sync_samples\\\
    \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   import os\n   from azure.servicebus import ServiceBusClient\n\
    \   servicebus_connection_str = os.environ['SERVICEBUS_CONNECTION_STR']\n   queue_name\
    \ = os.environ['SERVICEBUS_QUEUE_NAME']\n   servicebus_client = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   with servicebus_client:\n       queue_sender = servicebus_client.get_queue_sender(queue_name=queue_name)\n\
    \n   ````\n"
- uid: azure.servicebus.ServiceBusClient.get_subscription_receiver
  name: get_subscription_receiver
  summary: Get ServiceBusReceiver for the specific subscription under the topic.
  signature: 'get_subscription_receiver(topic_name: str, subscription_name: str, *,
    session_id: str | ~typing.Literal[<ServiceBusSessionFilter.NEXT_AVAILABLE: 0>]
    | None = None, sub_queue: ~azure.servicebus._common.constants.ServiceBusSubQueue
    | str | None = None, receive_mode: ~azure.servicebus._common.constants.ServiceBusReceiveMode
    | str = ServiceBusReceiveMode.PEEK_LOCK, max_wait_time: float | None = None, auto_lock_renewer:
    ~azure.servicebus._common.auto_lock_renewer.AutoLockRenewer | None = None, prefetch_count:
    int = 0, **kwargs: ~typing.Any) -> ServiceBusReceiver'
  parameters:
  - name: topic_name
    description: The name of specific Service Bus Topic the client connects to.
    isRequired: true
    types:
    - <xref:str>
  - name: subscription_name
    description: 'The name of specific Service Bus Subscription

      under the given Service Bus Topic.'
    isRequired: true
    types:
    - <xref:str>
  keywordOnlyParameters:
  - name: session_id
    description: 'A specific session from which to receive. This must be specified
      for a

      sessionful subscription, otherwise it must be None. In order to receive messages
      from the next available

      session, set this to ~azure.servicebus.NEXT_AVAILABLE_SESSION.'
    types:
    - <xref:str>
    - <xref:azure.servicebus.NEXT_AVAILABLE_SESSION>
  - name: sub_queue
    description: 'If specified, the subqueue this receiver will connect to.

      This includes the DEAD_LETTER and TRANSFER_DEAD_LETTER queues, holds messages
      that can''t be delivered to any

      receiver or messages that can''t be processed.

      The default is None, meaning connect to the primary queue.  Can be assigned
      values from *ServiceBusSubQueue*

      enum or equivalent string values "deadletter" and "transferdeadletter".'
    types:
    - <xref:str>
    - <xref:azure.servicebus.ServiceBusSubQueue>
    - <xref:None>
  - name: receive_mode
    description: 'The receive_mode with which messages will be retrieved from the
      entity. The two options

      are PEEK_LOCK and RECEIVE_AND_DELETE. Messages received with PEEK_LOCK must
      be settled within a given

      lock period before they will be removed from the subscription. Messages received
      with RECEIVE_AND_DELETE

      will be immediately removed from the subscription, and cannot be subsequently
      rejected or re-received if

      the client fails to process the message. The default receive_mode is PEEK_LOCK.'
    defaultValue: ServiceBusReceiveMode.PEEK_LOCK
    types:
    - <xref:typing.Union>[<xref:azure.servicebus.ServiceBusReceiveMode>, <xref:str>]
  - name: max_wait_time
    description: 'The timeout in seconds to wait for the first and subsequent

      messages to arrive. If no messages arrive, and no timeout is specified, this
      call will not return

      until the connection is closed. The default value is None, meaning no timeout.
      On a sessionful

      queue/topic when NEXT_AVAILABLE_SESSION is specified, this will act as the timeout
      for connecting.

      If connection errors are occurring due to write timing out,the connection timeout

      value may need to be adjusted. See the *socket_timeout* optional parameter for
      more details.'
    types:
    - <xref:typing.Optional>[<xref:float>]
  - name: auto_lock_renewer
    description: 'An ~azure.servicebus.AutoLockRenewer

      can be provided such that messages are automatically registered on receipt.
      If the receiver is a session

      receiver, it will apply to the session instead.'
    types:
    - <xref:typing.Optional>[<xref:azure.servicebus.AutoLockRenewer>]
  - name: prefetch_count
    description: 'The maximum number of messages to cache with each request to the
      service.

      This setting is only for advanced performance tuning. Increasing this value
      will improve message throughput

      performance but increase the chance that messages will expire while they are
      cached if they''re not

      processed fast enough.

      The default value is 0, meaning messages will be received from the service and
      processed one at a time.

      In the case of prefetch_count being 0, *ServiceBusReceiver.receive_messages*
      would try to cache

      *max_message_count* (if provided) within its request to the service.

      WARNING: If prefetch_count > 0 and RECEIVE_AND_DELETE mode is used, all prefetched
      messages will stay in

      the in-memory prefetch buffer until they''re received into the application.
      If the application ends before

      the messages are received into the application, those messages will be lost
      and unable to be recovered.

      Therefore, it''s recommended that PEEK_LOCK mode be used with prefetch.'
    types:
    - <xref:int>
  - name: client_identifier
    description: 'A string-based identifier to uniquely identify the receiver instance.

      Service Bus will associate it with some error messages for easier correlation
      of errors.

      If not specified, a unique id will be generated.'
    types:
    - <xref:str>
  - name: socket_timeout
    description: 'The time in seconds that the underlying socket on the connection
      should

      wait when sending and receiving data before timing out. The default value is
      0.2 for TransportType.Amqp

      and 1 for TransportType.AmqpOverWebsocket. If connection errors are occurring
      due to write timing out,

      a larger than default value may need to be passed in.'
    types:
    - <xref:float>
  return:
    description: A subscription receiver.
    types:
    - <xref:azure.servicebus.ServiceBusReceiver>
  examples:
  - "Create a new instance of the ServiceBusReceiver from ServiceBusClient.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\
    \\py2docfx\\\\dist_temp\\\\211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\sync_samples\\\
    \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   import os\n   from azure.servicebus import ServiceBusClient\n\
    \   servicebus_connection_str = os.environ['SERVICEBUS_CONNECTION_STR']\n   topic_name\
    \ = os.environ[\"SERVICEBUS_TOPIC_NAME\"]\n   subscription_name = os.environ[\"\
    SERVICEBUS_SUBSCRIPTION_NAME\"]\n   servicebus_client = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   with servicebus_client:\n       subscription_receiver = servicebus_client.get_subscription_receiver(\n\
    \           topic_name=topic_name,\n           subscription_name=subscription_name,\n\
    \       )\n\n   ````\n"
- uid: azure.servicebus.ServiceBusClient.get_topic_sender
  name: get_topic_sender
  summary: Get ServiceBusSender for the specific topic.
  signature: 'get_topic_sender(topic_name: str, *, client_identifier: str | None =
    None, socket_timeout: float | None = None, **kwargs: Any) -> ServiceBusSender'
  parameters:
  - name: topic_name
    description: The path of specific Service Bus Topic the client connects to.
    isRequired: true
    types:
    - <xref:str>
  keywordOnlyParameters:
  - name: client_identifier
    description: 'A string-based identifier to uniquely identify the sender instance.

      Service Bus will associate it with some error messages for easier correlation
      of errors.

      If not specified, a unique id will be generated.'
    types:
    - <xref:str>
    - <xref:None>
  - name: socket_timeout
    description: 'The time in seconds that the underlying socket on the connection
      should

      wait when sending and receiving data before timing out. If None, a default value
      of 0.2 for TransportType.Amqp

      and 1 for TransportType.AmqpOverWebsocket is used. If connection errors are
      occurring due to write timing out,

      a larger than default value may need to be passed in.'
    types:
    - <xref:float>
    - <xref:None>
  return:
    description: A topic sender.
    types:
    - <xref:azure.servicebus.ServiceBusSender>
  examples:
  - "Create a new instance of the ServiceBusSender from ServiceBusClient.<!--[!code-python[Main](les\\\
    sync_samples\\sample_code_servicebus.py )]-->\n\n<!-- literal_block {\"ids\":\
    \ [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"C:\\\\hostedtoolcache\\\\windows\\\\Python\\\\3.11.9\\\\x64\\\\Lib\\\\site-packages\\\
    \\py2docfx\\\\dist_temp\\\\211\\\\azure-servicebus-7.13.0b1\\\\samples\\\\sync_samples\\\
    \\sample_code_servicebus.py\", \"xml:space\": \"preserve\", \"force\": false,\
    \ \"language\": \"python\", \"highlight_args\": {\"linenostart\": 1}, \"linenos\"\
    : false} -->\n\n````python\n\n   import os\n   from azure.servicebus import ServiceBusClient\n\
    \   servicebus_connection_str = os.environ['SERVICEBUS_CONNECTION_STR']\n   topic_name\
    \ = os.environ['SERVICEBUS_TOPIC_NAME']\n   servicebus_client = ServiceBusClient.from_connection_string(conn_str=servicebus_connection_str)\n\
    \   with servicebus_client:\n       topic_sender = servicebus_client.get_topic_sender(topic_name=topic_name)\n\
    \n   ````\n"
