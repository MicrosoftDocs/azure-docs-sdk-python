### YamlMime:UniversalReference
api_name: []
items:
- children:
  - azure.eventhub.aio.EventHubConsumerClient.close
  - azure.eventhub.aio.EventHubConsumerClient.from_connection_string
  - azure.eventhub.aio.EventHubConsumerClient.get_eventhub_properties
  - azure.eventhub.aio.EventHubConsumerClient.get_partition_ids
  - azure.eventhub.aio.EventHubConsumerClient.get_partition_properties
  - azure.eventhub.aio.EventHubConsumerClient.receive
  - azure.eventhub.aio.EventHubConsumerClient.receive_batch
  class: azure.eventhub.aio.EventHubConsumerClient
  example:
  - "Create a new instance of the EventHubConsumerClient.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\"\
    : [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\21\\\\azure-eventhub-5.2.0\\\\samples\\\\\
    async_samples\\\\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\"\
    , \"language\": \"python\", \"linenos\": false, \"highlight_args\": {\"linenostart\"\
    : 1}} -->\n\n````python\n\n   import os\n   from azure.eventhub.aio import EventHubConsumerClient,\
    \ EventHubSharedKeyCredential\n\n   fully_qualified_namespace = os.environ['EVENT_HUB_HOSTNAME']\n\
    \   eventhub_name = os.environ['EVENT_HUB_NAME']\n   shared_access_policy = os.environ['EVENT_HUB_SAS_POLICY']\n\
    \   shared_access_key = os.environ['EVENT_HUB_SAS_KEY']\n\n   consumer = EventHubConsumerClient(fully_qualified_namespace=fully_qualified_namespace,\n\
    \                                     consumer_group='$Default',\n           \
    \                          eventhub_name=eventhub_name,\n                    \
    \                 credential=EventHubSharedKeyCredential(shared_access_policy,\
    \ shared_access_key))\n\n   ````\n"
  fullName: azure.eventhub.aio.EventHubConsumerClient
  inheritance:
  - inheritance:
    - inheritance:
      - type: builtins.object
      type: azure.eventhub._client_base.ClientBase
    type: azure.eventhub.aio._client_base_async.ClientBaseAsync
  langs:
  - python
  module: azure.eventhub.aio
  name: EventHubConsumerClient
  summary: 'The EventHubConsumerClient class defines a high level interface for

    receiving events from the Azure Event Hubs service.


    The main goal of *EventHubConsumerClient* is to receive events from all partitions
    of an EventHub with

    load-balancing and checkpointing.


    When multiple *EventHubConsumerClient* instances are running against the same
    event hub, consumer group and

    checkpointing location, the partitions will be evenly distributed among them.


    To enable load-balancing and persisted checkpoints, checkpoint_store must be set
    when creating the

    *EventHubConsumerClient*.

    If a checkpoint store is not provided, the checkpoint will be maintained internally
    in memory.


    An *EventHubConsumerClient* can also receive from a specific partition when you
    call its method *receive()* or

    *receive_batch()* and specify the partition_id.

    Load-balancing won''t work in single-partition mode. But users can still save
    checkpoints if the checkpoint_store

    is set.'
  syntax:
    parameters:
    - description: 'The fully qualified host name for the Event Hubs namespace.

        The namespace format is: *<yournamespace>.servicebus.windows.net*.'
      id: fully_qualified_namespace
      type:
      - str
    - description: The path of the specific Event Hub to connect the client to.
      id: eventhub_name
      type:
      - str
    - description: Receive events from the event hub for this consumer group.
      id: consumer_group
      type:
      - str
    - description: 'The credential object used for authentication which

        implements a particular interface for getting tokens. It accepts

        <xref:azure.eventhub.aio.EventHubSharedKeyCredential>, or credential objects

        generated by the azure-identity library and objects that implement the *get_token(self,
        *scopes)* method.'
      id: credential
      type:
      - azure.core.credentials.TokenCredential
    - description: Whether to output network trace logs to the logger. Default is
        *False*.
      id: logging_enable
      type:
      - bool
    - description: 'The time in seconds to wait for a token to be authorized by the
        service.

        The default value is 60 seconds. If set to 0, no timeout will be enforced
        from the client.'
      id: auth_timeout
      type:
      - float
    - description: The user agent that should be appended to the built-in user agent
        string.
      id: user_agent
      type:
      - str
    - description: 'The total number of attempts to redo a failed operation when an
        error occurs.

        Default value is 3. The context of *retry_total* in receiving is special:
        The *receive* method is implemented

        by a while-loop calling internal receive method in each iteration. In the
        *receive* case,

        *retry_total* specifies the numbers of retry after error raised by internal
        receive method in the while-loop.

        If retry attempts are exhausted, the *on_error* callback will be called (if
        provided) with the error information.

        The failed internal partition consumer will be closed (*on_partition_close*
        will be called if provided) and

        new internal partition consumer will be created (*on_partition_initialize*
        will be called if provided) to resume

        receiving.'
      id: retry_total
      type:
      - int
    - description: 'Timeout, in seconds, after which this client will close the underlying
        connection

        if there is no further activity. By default the value is None, meaning that
        the client will not shutdown due to

        inactivity unless initiated by the service.'
      id: idle_timeout
      type:
      - float
    - description: 'The type of transport protocol that will be used for communicating
        with

        the Event Hubs service. Default is *TransportType.Amqp*.'
      id: transport_type
      type:
      - azure.eventhub.TransportType
    - description: 'HTTP proxy settings. This must be a dictionary with the following

        keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

        Additionally the following keys may also be present: *''username'', ''password''*.'
      id: http_proxy
      type:
      - dict
    - description: 'A manager that stores the partition load-balancing and checkpoint
        data

        when receiving events. The checkpoint store will be used in both cases of
        receiving from all partitions

        or a single partition. In the latter case load-balancing does not apply.

        If a checkpoint store is not provided, the checkpoint will be maintained internally

        in memory, and the *EventHubConsumerClient* instance will receive events without
        load-balancing.'
      id: checkpoint_store
      type:
      - azure.eventhub.aio.CheckpointStore
    - description: 'When load-balancing kicks in. This is the interval, in seconds,

        between two load-balancing evaluations. Default is 10 seconds.'
      id: load_balancing_interval
      type:
      - float
    - description: 'A partition ownership will expire after this number

        of seconds. Every load-balancing evaluation will automatically extend the
        ownership expiration time.

        Default is 6 * load_balancing_interval, i.e. 60 seconds when using the default
        load_balancing_interval

        of 10 seconds.'
      id: partition_ownership_expiration_interval
      type:
      - float
    - description: 'When load-balancing kicks in,

        it will use this strategy to claim and balance the partition ownership.

        Use "greedy" or *LoadBalancingStrategy.GREEDY* for the greedy strategy, which,
        for every

        load-balancing evaluation, will grab as many unclaimed partitions required
        to balance the load.

        Use "balanced" or *LoadBalancingStrategy.BALANCED* for the balanced strategy,
        which, for every load-balancing

        evaluation, claims only one partition that is not claimed by other *EventHubConsumerClient*.

        If all partitions of an EventHub are claimed by other *EventHubConsumerClient*
        and this client has claimed

        too few partitions, this client will steal one partition from other clients
        for every load-balancing

        evaluation regardless of the load balancing strategy.

        Greedy strategy is used by default.'
      id: load_balancing_strategy
      type:
      - str
      - azure.eventhub.LoadBalancingStrategy
  type: class
  uid: azure.eventhub.aio.EventHubConsumerClient
- class: azure.eventhub.aio.EventHubConsumerClient
  example:
  - "Close down the client.<!--[!code-python[Main](les\\async_samples\\sample_code_eventhub_async.py\
    \ )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\": [], \"names\": [], \"\
    dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\
    \\21\\\\azure-eventhub-5.2.0\\\\samples\\\\async_samples\\\\sample_code_eventhub_async.py\"\
    , \"xml:space\": \"preserve\", \"language\": \"python\", \"linenos\": false, \"\
    highlight_args\": {\"linenostart\": 1}} -->\n\n````python\n\n   import os\n\n\
    \   event_hub_connection_str = os.environ['EVENT_HUB_CONN_STR']\n   eventhub_name\
    \ = os.environ['EVENT_HUB_NAME']\n\n   from azure.eventhub.aio import EventHubConsumerClient\n\
    \   consumer = EventHubConsumerClient.from_connection_string(\n       conn_str=event_hub_connection_str,\n\
    \       consumer_group='$Default',\n       eventhub_name=eventhub_name  # EventHub\
    \ name should be specified if it doesn't show up in connection string.\n   )\n\
    \n   logger = logging.getLogger(\"azure.eventhub\")\n\n   async def on_event(partition_context,\
    \ event):\n       # Put your code here.\n       # If the operation is i/o intensive,\
    \ async will have better performance.\n       logger.info(\"Received event from\
    \ partition: {}\".format(partition_context.partition_id))\n\n   # The receive\
    \ method is a coroutine which will be blocking when awaited.\n   # It can be executed\
    \ in an async task for non-blocking behavior, and combined with the 'close' method.\n\
    \n   recv_task = asyncio.ensure_future(consumer.receive(on_event=on_event))\n\
    \   await asyncio.sleep(3)  # keep receiving for 3 seconds\n   recv_task.cancel()\
    \  # stop receiving\n\n   # Close down the consumer handler explicitly.\n   await\
    \ consumer.close()\n\n   ````\n"
  fullName: azure.eventhub.aio.EventHubConsumerClient.close
  langs:
  - python
  module: azure.eventhub.aio
  name: close() -> None
  namewithoutparameters: close
  summary: Stop retrieving events from the Event Hub and close the underlying AMQP
    connection and links.
  syntax:
    content: close() -> None
    return:
      type:
      - None
  type: method
  uid: azure.eventhub.aio.EventHubConsumerClient.close
- class: azure.eventhub.aio.EventHubConsumerClient
  example:
  - "Create a new instance of the EventHubConsumerClient from connection string.<!--[!code-python[Main](les\\\
    async_samples\\sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\"\
    : [], \"classes\": [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\"\
    : \"D:\\\\a\\\\1\\\\s\\\\dist_temp\\\\21\\\\azure-eventhub-5.2.0\\\\samples\\\\\
    async_samples\\\\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\"\
    , \"language\": \"python\", \"linenos\": false, \"highlight_args\": {\"linenostart\"\
    : 1}} -->\n\n````python\n\n   import os\n   from azure.eventhub.aio import EventHubConsumerClient\n\
    \   event_hub_connection_str = os.environ['EVENT_HUB_CONN_STR']\n   eventhub_name\
    \ = os.environ['EVENT_HUB_NAME']\n   consumer = EventHubConsumerClient.from_connection_string(\n\
    \       conn_str=event_hub_connection_str,\n       consumer_group='$Default',\n\
    \       eventhub_name=eventhub_name  # EventHub name should be specified if it\
    \ doesn't show up in connection string.\n   )\n\n   ````\n"
  fullName: azure.eventhub.aio.EventHubConsumerClient.from_connection_string
  langs:
  - python
  module: azure.eventhub.aio
  name: from_connection_string
  namewithoutparameters: from_connection_string
  summary: Create an EventHubConsumerClient from a connection string.
  syntax:
    parameters:
    - description: The connection string of an Event Hub.
      id: conn_str
      isRequired: true
      type:
      - str
    - description: Receive events from the Event Hub for this consumer group.
      id: consumer_group
      isRequired: true
      type:
      - str
    - description: The path of the specific Event Hub to connect the client to.
      id: eventhub_name
      isRequired: true
      type:
      - str
    - description: Whether to output network trace logs to the logger. Default is
        *False*.
      id: logging_enable
      isRequired: true
      type:
      - bool
    - description: 'HTTP proxy settings. This must be a dictionary with the following

        keys: *''proxy_hostname''* (str value) and *''proxy_port''* (int value).

        Additionally the following keys may also be present: *''username'', ''password''*.'
      id: http_proxy
      isRequired: true
      type:
      - dict
    - description: 'The time in seconds to wait for a token to be authorized by the
        service.

        The default value is 60 seconds. If set to 0, no timeout will be enforced
        from the client.'
      id: auth_timeout
      isRequired: true
      type:
      - float
    - description: The user agent that should be appended to the built-in user agent
        string.
      id: user_agent
      isRequired: true
      type:
      - str
    - description: 'The total number of attempts to redo a failed operation when an
        error occurs.

        Default value is 3. The context of *retry_total* in receiving is special:
        The *receive* method is implemented

        by a while-loop calling internal receive method in each iteration. In the
        *receive* case,

        *retry_total* specifies the numbers of retry after error raised by internal
        receive method in the while-loop.

        If retry attempts are exhausted, the *on_error* callback will be called (if
        provided) with the error

        information. The failed internal partition consumer will be closed (*on_partition_close*
        will be called

        if provided) and new internal partition consumer will be created (*on_partition_initialize*
        will be called if

        provided) to resume receiving.'
      id: retry_total
      isRequired: true
      type:
      - int
    - description: 'Timeout, in seconds, after which this client will close the underlying
        connection

        if there is no further activity. By default the value is None, meaning that
        the client will not shutdown due

        to inactivity unless initiated by the service.'
      id: idle_timeout
      isRequired: true
      type:
      - float
    - description: 'The type of transport protocol that will be used for communicating
        with

        the Event Hubs service. Default is *TransportType.Amqp*.'
      id: transport_type
      isRequired: true
      type:
      - azure.eventhub.TransportType
    - description: 'A manager that stores the partition load-balancing and checkpoint
        data

        when receiving events. The checkpoint store will be used in both cases of
        receiving from all partitions

        or a single partition. In the latter case load-balancing does not apply.

        If a checkpoint store is not provided, the checkpoint will be maintained internally

        in memory, and the *EventHubConsumerClient* instance will receive events without
        load-balancing.'
      id: checkpoint_store
      isRequired: true
      type:
      - azure.eventhub.aio.CheckpointStore
    - description: 'When load-balancing kicks in. This is the interval, in seconds,

        between two load-balancing evaluations. Default is 10 seconds.'
      id: load_balancing_interval
      isRequired: true
      type:
      - float
    - description: 'A partition ownership will expire after this number

        of seconds. Every load-balancing evaluation will automatically extend the
        ownership expiration time.

        Default is 6 * load_balancing_interval, i.e. 60 seconds when using the default
        load_balancing_interval

        of 10 seconds.'
      id: partition_ownership_expiration_interval
      isRequired: true
      type:
      - float
    - description: 'When load-balancing kicks in,

        it will use this strategy to claim and balance the partition ownership.

        Use "greedy" or *LoadBalancingStrategy.GREEDY* for the greedy strategy, which,
        for every

        load-balancing evaluation, will grab as many unclaimed partitions required
        to balance the load.

        Use "balanced" or *LoadBalancingStrategy.BALANCED* for the balanced strategy,
        which, for every load-balancing

        evaluation, claims only one partition that is not claimed by other *EventHubConsumerClient*.

        If all partitions of an EventHub are claimed by other *EventHubConsumerClient*
        and this client has claimed

        too few partitions, this client will steal one partition from other clients
        for every load-balancing

        evaluation regardless of the load balancing strategy.

        Greedy strategy is used by default.'
      id: load_balancing_strategy
      isRequired: true
      type:
      - str
      - azure.eventhub.LoadBalancingStrategy
    return:
      type:
      - azure.eventhub.aio.EventHubConsumerClient
  type: method
  uid: azure.eventhub.aio.EventHubConsumerClient.from_connection_string
- class: azure.eventhub.aio.EventHubConsumerClient
  fullName: azure.eventhub.aio.EventHubConsumerClient.get_eventhub_properties
  langs:
  - python
  module: azure.eventhub.aio
  name: get_eventhub_properties() -> typing.Dict[str, typing.Any]
  namewithoutparameters: get_eventhub_properties
  summary: "Get properties of the Event Hub.\n\nKeys in the returned dictionary include:\n\
    \n   * *eventhub_name* (str) \n\n   * *created_at* (UTC datetime.datetime) \n\n\
    \   * *partition_ids* (list[str])"
  syntax:
    content: get_eventhub_properties() -> typing.Dict[str, typing.Any]
    return:
      type:
      - dict
  type: method
  uid: azure.eventhub.aio.EventHubConsumerClient.get_eventhub_properties
- class: azure.eventhub.aio.EventHubConsumerClient
  fullName: azure.eventhub.aio.EventHubConsumerClient.get_partition_ids
  langs:
  - python
  module: azure.eventhub.aio
  name: get_partition_ids() -> typing.List[str]
  namewithoutparameters: get_partition_ids
  summary: Get partition IDs of the Event Hub.
  syntax:
    content: get_partition_ids() -> typing.List[str]
    return:
      type:
      - list[str]
  type: method
  uid: azure.eventhub.aio.EventHubConsumerClient.get_partition_ids
- class: azure.eventhub.aio.EventHubConsumerClient
  exceptions:
  - type: azure.eventhub.exceptions.EventHubError
  fullName: azure.eventhub.aio.EventHubConsumerClient.get_partition_properties
  langs:
  - python
  module: azure.eventhub.aio
  name: 'get_partition_properties(partition_id: str) -> typing.Dict[str, typing.Any]'
  namewithoutparameters: get_partition_properties
  summary: "Get properties of the specified partition.\n\nKeys in the properties dictionary\
    \ include:\n\n   * *eventhub_name* (str) \n\n   * *id* (str) \n\n   * *beginning_sequence_number*\
    \ (int) \n\n   * *last_enqueued_sequence_number* (int) \n\n   * *last_enqueued_offset*\
    \ (str) \n\n   * *last_enqueued_time_utc* (UTC datetime.datetime) \n\n   * *is_empty*\
    \ (bool)"
  syntax:
    content: 'get_partition_properties(partition_id: str) -> typing.Dict[str, typing.Any]'
    parameters:
    - description: The target partition ID.
      id: partition_id
      isRequired: true
      type:
      - str
    return:
      type:
      - dict
  type: method
  uid: azure.eventhub.aio.EventHubConsumerClient.get_partition_properties
- class: azure.eventhub.aio.EventHubConsumerClient
  example:
  - "Receive events from the EventHub.<!--[!code-python[Main](les\\async_samples\\\
    sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\21\\\\azure-eventhub-5.2.0\\\\samples\\\\async_samples\\\
    \\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\", \"language\":\
    \ \"python\", \"linenos\": false, \"highlight_args\": {\"linenostart\": 1}} -->\n\
    \n````python\n\n       logger = logging.getLogger(\"azure.eventhub\")\n\n    \
    \   async def on_event(partition_context, event):\n           # Put your code\
    \ here.\n           # If the operation is i/o intensive, async will have better\
    \ performance.\n           logger.info(\"Received event from partition: {}\".format(partition_context.partition_id))\n\
    \n       async with consumer:\n           await consumer.receive(\n          \
    \     on_event=on_event,\n               starting_position=\"-1\",  # \"-1\" is\
    \ from the beginning of the partition.\n           )\n\n   ````\n"
  fullName: azure.eventhub.aio.EventHubConsumerClient.receive
  langs:
  - python
  module: azure.eventhub.aio
  name: receive
  namewithoutparameters: receive
  summary: Receive events from partition(s), with optional load-balancing and checkpointing.
  syntax:
    parameters:
    - description: 'The callback function for handling a received event. The callback
        takes two

        parameters: *partition_context* which contains partition context and *event*
        which is the received event.

        The callback function should be defined like: *on_event(partition_context,
        event)*.

        For detailed partition context information, please refer to

        <xref:azure.eventhub.aio.PartitionContext>.'
      id: on_event
      isRequired: true
      type:
      - Callable[azure.eventhub.aio.PartitionContext, Optional[azure.eventhub.EventData]]
    - description: 'The maximum interval in seconds that the event processor will
        wait before calling

        the callback. If no events are received within this interval, the *on_event*
        callback will be called with

        *None*.

        If this value is set to *None* or 0 (the default), the callback will not be
        called until an event is received.'
      id: max_wait_time
      isRequired: true
      type:
      - float
    - description: 'If specified, the client will receive from this partition only.

        Otherwise the client will receive from all partitions.'
      id: partition_id
      isRequired: true
      type:
      - str
    - description: 'The priority for an exclusive consumer. An exclusive

        consumer will be created if owner_level is set. A consumer with a higher owner_level
        has higher exclusive

        priority. The owner level is also know as the ''epoch value'' of the consumer.'
      id: owner_level
      isRequired: true
      type:
      - int
    - description: 'The number of events to prefetch from the service

        for processing. Default is 300.'
      id: prefetch
      isRequired: true
      type:
      - int
    - description: 'Indicates whether the consumer should request information

        on the last-enqueued event on its associated partition, and track that information
        as events are received.

        When information about the partitions last-enqueued event is being tracked,
        each event received from the

        Event Hubs service will carry metadata about the partition. This results in
        a small amount of additional

        network bandwidth consumption that is generally a favorable trade-off when
        considered against periodically

        making requests for partition properties using the Event Hub client.

        It is set to *False* by default.'
      id: track_last_enqueued_event_properties
      isRequired: true
      type:
      - bool
    - description: 'Start receiving from this event position

        if there is no checkpoint data for a partition. Checkpoint data will be used
        if available. This can be a

        a dict with partition ID as the key and position as the value for individual
        partitions, or a single

        value for all partitions. The value type can be str, int or datetime.datetime.
        Also supported are the

        values "-1" for receiving from the beginning of the stream, and "@latest"
        for receiving only new events.'
      id: starting_position
      isRequired: true
      type:
      - str, int, datetime.datetime
      - dict[str,Any]
    - description: 'Determine whether the given starting_position is inclusive(>=)
        or

        not (>). True for inclusive and False for exclusive. This can be a dict with
        partition ID as the key and

        bool as the value indicating whether the starting_position for a specific
        partition is inclusive or not.

        This can also be a single bool value for all starting_position. The default
        value is False.'
      id: starting_position_inclusive
      isRequired: true
      type:
      - bool
      - dict[str,bool]
    - description: 'The callback function that will be called when an error is raised
        during receiving

        after retry attempts are exhausted, or during the process of load-balancing.

        The callback takes two parameters: *partition_context* which contains partition
        information

        and *error* being the exception. *partition_context* could be None if the
        error is raised during

        the process of load-balance. The callback should be defined like: *on_error(partition_context,
        error)*.

        The *on_error* callback will also be called if an unhandled exception is raised
        during

        the *on_event* callback.'
      id: on_error
      isRequired: true
      type:
      - Callable[[azure.eventhub.aio.PartitionContext, Exception]]
    - description: 'The callback function that will be called after a consumer for
        a certain

        partition finishes initialization. It would also be called when a new internal
        partition consumer is created

        to take over the receiving process for a failed and closed internal partition
        consumer.

        The callback takes a single parameter: *partition_context*

        which contains the partition information. The callback should be defined

        like: *on_partition_initialize(partition_context)*.'
      id: on_partition_initialize
      isRequired: true
      type:
      - Callable[[azure.eventhub.aio.PartitionContext]]
    - description: 'The callback function that will be called after a consumer for
        a certain

        partition is closed. It would be also called when error is raised during receiving
        after retry attempts are

        exhausted. The callback takes two parameters: *partition_context* which contains
        partition

        information and *reason* for the close. The callback should be defined like:

        *on_partition_close(partition_context, reason)*.

        Please refer to <xref:azure.eventhub.CloseReason> for the various closing
        reasons.'
      id: on_partition_close
      isRequired: true
      type:
      - Callable[[azure.eventhub.aio.PartitionContext, azure.eventhub.CloseReason]]
    return:
      type:
      - None
  type: method
  uid: azure.eventhub.aio.EventHubConsumerClient.receive
- class: azure.eventhub.aio.EventHubConsumerClient
  example:
  - "Receive events in batches from the EventHub.<!--[!code-python[Main](les\\async_samples\\\
    sample_code_eventhub_async.py )]-->\n\n<!-- literal_block {\"ids\": [], \"classes\"\
    : [], \"names\": [], \"dupnames\": [], \"backrefs\": [], \"source\": \"D:\\\\\
    a\\\\1\\\\s\\\\dist_temp\\\\21\\\\azure-eventhub-5.2.0\\\\samples\\\\async_samples\\\
    \\sample_code_eventhub_async.py\", \"xml:space\": \"preserve\", \"language\":\
    \ \"python\", \"linenos\": false, \"highlight_args\": {\"linenostart\": 1}} -->\n\
    \n````python\n\n       logger = logging.getLogger(\"azure.eventhub\")\n\n    \
    \   async def on_event_batch(partition_context, event_batch):\n           # Put\
    \ your code here.\n           # If the operation is i/o intensive, async will\
    \ have better performance.\n           logger.info(\n               \"{} events\
    \ received from partition: {}\".format(len(event_batch), partition_context.partition_id)\n\
    \           )\n\n       async with consumer:\n           await consumer.receive_batch(\n\
    \               on_event_batch=on_event_batch,\n               starting_position=\"\
    -1\",  # \"-1\" is from the beginning of the partition.\n           )\n\n   ````\n"
  fullName: azure.eventhub.aio.EventHubConsumerClient.receive_batch
  langs:
  - python
  module: azure.eventhub.aio
  name: receive_batch
  namewithoutparameters: receive_batch
  summary: Receive events from partition(s) in batches, with optional load-balancing
    and checkpointing.
  syntax:
    parameters:
    - description: 'The callback function for handling a batch of received events.
        The callback takes two

        parameters: *partition_context* which contains partition context and *event_batch*,
        which is the received

        events. The callback function should be defined like: *on_event_batch(partition_context,
        event_batch)*.

        *event_batch* could be an empty list if *max_wait_time* is not None nor 0
        and no event is received

        after *max_wait_time*.

        For detailed partition context information, please refer to

        <xref:azure.eventhub.aio.PartitionContext>.'
      id: on_event_batch
      isRequired: true
      type:
      - Callable[azure.eventhub.aio.PartitionContext, List[azure.eventhub.EventData]]
    - description: 'The maximum number of events in a batch passed to callback *on_event_batch*.

        If the actual received number of events is larger than *max_batch_size*, the
        received events are divided into

        batches and call the callback for each batch with up to *max_batch_size* events.'
      id: max_batch_size
      isRequired: true
      type:
      - int
    - description: 'The maximum interval in seconds that the event processor will
        wait before

        calling the callback.

        If no events are received within this interval, the *on_event_batch* callback
        will be called

        with an empty list.

        If this value is set to *None* or 0 (the default), the callback will not be
        called until events are received.'
      id: max_wait_time
      isRequired: true
      type:
      - float
    - description: 'If specified, the client will receive from this partition only.

        Otherwise the client will receive from all partitions.'
      id: partition_id
      isRequired: true
      type:
      - str
    - description: 'The priority for an exclusive consumer. An exclusive

        consumer will be created if owner_level is set. A consumer with a higher owner_level
        has higher exclusive

        priority. The owner level is also know as the ''epoch value'' of the consumer.'
      id: owner_level
      isRequired: true
      type:
      - int
    - description: 'The number of events to prefetch from the service

        for processing. Default is 300.'
      id: prefetch
      isRequired: true
      type:
      - int
    - description: 'Indicates whether the consumer should request information

        on the last-enqueued event on its associated partition, and track that information
        as events are received.

        When information about the partitions last-enqueued event is being tracked,
        each event received from the

        Event Hubs service will carry metadata about the partition. This results in
        a small amount of additional

        network bandwidth consumption that is generally a favorable trade-off when
        considered against periodically

        making requests for partition properties using the Event Hub client.

        It is set to *False* by default.'
      id: track_last_enqueued_event_properties
      isRequired: true
      type:
      - bool
    - description: 'Start receiving from this event position

        if there is no checkpoint data for a partition. Checkpoint data will be used
        if available. This can be a

        a dict with partition ID as the key and position as the value for individual
        partitions, or a single

        value for all partitions. The value type can be str, int or datetime.datetime.
        Also supported are the

        values "-1" for receiving from the beginning of the stream, and "@latest"
        for receiving only new events.'
      id: starting_position
      isRequired: true
      type:
      - str, int, datetime.datetime
      - dict[str,Any]
    - description: 'Determine whether the given starting_position is inclusive(>=)
        or

        not (>). True for inclusive and False for exclusive. This can be a dict with
        partition ID as the key and

        bool as the value indicating whether the starting_position for a specific
        partition is inclusive or not.

        This can also be a single bool value for all starting_position. The default
        value is False.'
      id: starting_position_inclusive
      isRequired: true
      type:
      - bool
      - dict[str,bool]
    - description: 'The callback function that will be called when an error is raised
        during receiving

        after retry attempts are exhausted, or during the process of load-balancing.

        The callback takes two parameters: *partition_context* which contains partition
        information

        and *error* being the exception. *partition_context* could be None if the
        error is raised during

        the process of load-balance. The callback should be defined like: *on_error(partition_context,
        error)*.

        The *on_error* callback will also be called if an unhandled exception is raised
        during

        the *on_event* callback.'
      id: on_error
      isRequired: true
      type:
      - Callable[[azure.eventhub.aio.PartitionContext, Exception]]
    - description: 'The callback function that will be called after a consumer for
        a certain

        partition finishes initialization. It would also be called when a new internal
        partition consumer is created

        to take over the receiving process for a failed and closed internal partition
        consumer.

        The callback takes a single parameter: *partition_context*

        which contains the partition information. The callback should be defined

        like: *on_partition_initialize(partition_context)*.'
      id: on_partition_initialize
      isRequired: true
      type:
      - Callable[[azure.eventhub.aio.PartitionContext]]
    - description: 'The callback function that will be called after a consumer for
        a certain

        partition is closed. It would be also called when error is raised during receiving
        after retry attempts are

        exhausted. The callback takes two parameters: *partition_context* which contains
        partition

        information and *reason* for the close. The callback should be defined like:

        *on_partition_close(partition_context, reason)*.

        Please refer to <xref:azure.eventhub.CloseReason> for the various closing
        reasons.'
      id: on_partition_close
      isRequired: true
      type:
      - Callable[[azure.eventhub.aio.PartitionContext, azure.eventhub.CloseReason]]
    return:
      type:
      - None
  type: method
  uid: azure.eventhub.aio.EventHubConsumerClient.receive_batch
references:
- fullName: azure.eventhub.aio.EventHubConsumerClient.close
  isExternal: false
  name: close() -> None
  parent: azure.eventhub.aio.EventHubConsumerClient
  uid: azure.eventhub.aio.EventHubConsumerClient.close
- fullName: azure.eventhub.aio.EventHubConsumerClient.from_connection_string
  isExternal: false
  name: from_connection_string
  parent: azure.eventhub.aio.EventHubConsumerClient
  uid: azure.eventhub.aio.EventHubConsumerClient.from_connection_string
- fullName: azure.eventhub.aio.EventHubConsumerClient.get_eventhub_properties
  isExternal: false
  name: get_eventhub_properties() -> typing.Dict[str, typing.Any]
  parent: azure.eventhub.aio.EventHubConsumerClient
  uid: azure.eventhub.aio.EventHubConsumerClient.get_eventhub_properties
- fullName: azure.eventhub.aio.EventHubConsumerClient.get_partition_ids
  isExternal: false
  name: get_partition_ids() -> typing.List[str]
  parent: azure.eventhub.aio.EventHubConsumerClient
  uid: azure.eventhub.aio.EventHubConsumerClient.get_partition_ids
- fullName: azure.eventhub.aio.EventHubConsumerClient.get_partition_properties
  isExternal: false
  name: 'get_partition_properties(partition_id: str) -> typing.Dict[str, typing.Any]'
  parent: azure.eventhub.aio.EventHubConsumerClient
  uid: azure.eventhub.aio.EventHubConsumerClient.get_partition_properties
- fullName: azure.eventhub.aio.EventHubConsumerClient.receive
  isExternal: false
  name: receive
  parent: azure.eventhub.aio.EventHubConsumerClient
  uid: azure.eventhub.aio.EventHubConsumerClient.receive
- fullName: azure.eventhub.aio.EventHubConsumerClient.receive_batch
  isExternal: false
  name: receive_batch
  parent: azure.eventhub.aio.EventHubConsumerClient
  uid: azure.eventhub.aio.EventHubConsumerClient.receive_batch
- fullName: list[str]
  name: list[str]
  spec.python:
  - fullName: list
    name: list
    uid: list
  - fullName: '['
    name: '['
  - fullName: str
    name: str
    uid: str
  - fullName: ']'
    name: ']'
  uid: list[str]
- fullName: Callable[azure.eventhub.aio.PartitionContext, Optional[azure.eventhub.EventData]]
  name: Callable[PartitionContext, Optional[EventData]]
  spec.python:
  - fullName: Callable
    name: Callable
    uid: Callable
  - fullName: '['
    name: '['
  - fullName: azure.eventhub.aio.PartitionContext
    name: PartitionContext
    uid: azure.eventhub.aio.PartitionContext
  - fullName: ', '
    name: ', '
  - fullName: Optional
    name: Optional
    uid: Optional
  - fullName: '['
    name: '['
  - fullName: azure.eventhub.EventData
    name: EventData
    uid: azure.eventhub.EventData
  - fullName: ']'
    name: ']'
  - fullName: ']'
    name: ']'
  uid: Callable[azure.eventhub.aio.PartitionContext, Optional[azure.eventhub.EventData]]
- fullName: str, int, datetime.datetime
  name: str, int, datetime
  spec.python:
  - fullName: str
    name: str
    uid: str
  - fullName: ', '
    name: ', '
  - fullName: int
    name: int
    uid: int
  - fullName: ', '
    name: ', '
  - fullName: datetime.datetime
    name: datetime
    uid: datetime.datetime
  uid: str, int, datetime.datetime
- fullName: dict[str,Any]
  name: dict[str,Any]
  spec.python:
  - fullName: dict
    name: dict
    uid: dict
  - fullName: '['
    name: '['
  - fullName: str,Any
    name: str,Any
    uid: str,Any
  - fullName: ']'
    name: ']'
  uid: dict[str,Any]
- fullName: dict[str,bool]
  name: dict[str,bool]
  spec.python:
  - fullName: dict
    name: dict
    uid: dict
  - fullName: '['
    name: '['
  - fullName: str,bool
    name: str,bool
    uid: str,bool
  - fullName: ']'
    name: ']'
  uid: dict[str,bool]
- fullName: Callable[[azure.eventhub.aio.PartitionContext, Exception]]
  name: Callable[[PartitionContext, Exception]]
  spec.python:
  - fullName: Callable
    name: Callable
    uid: Callable
  - fullName: '['
    name: '['
  - fullName: '['
    name: '['
  - fullName: azure.eventhub.aio.PartitionContext
    name: PartitionContext
    uid: azure.eventhub.aio.PartitionContext
  - fullName: ', '
    name: ', '
  - fullName: Exception
    name: Exception
    uid: Exception
  - fullName: ']'
    name: ']'
  - fullName: ']'
    name: ']'
  uid: Callable[[azure.eventhub.aio.PartitionContext, Exception]]
- fullName: Callable[[azure.eventhub.aio.PartitionContext]]
  name: Callable[[PartitionContext]]
  spec.python:
  - fullName: Callable
    name: Callable
    uid: Callable
  - fullName: '['
    name: '['
  - fullName: '['
    name: '['
  - fullName: azure.eventhub.aio.PartitionContext
    name: PartitionContext
    uid: azure.eventhub.aio.PartitionContext
  - fullName: ']'
    name: ']'
  - fullName: ']'
    name: ']'
  uid: Callable[[azure.eventhub.aio.PartitionContext]]
- fullName: Callable[[azure.eventhub.aio.PartitionContext, azure.eventhub.CloseReason]]
  name: Callable[[PartitionContext, CloseReason]]
  spec.python:
  - fullName: Callable
    name: Callable
    uid: Callable
  - fullName: '['
    name: '['
  - fullName: '['
    name: '['
  - fullName: azure.eventhub.aio.PartitionContext
    name: PartitionContext
    uid: azure.eventhub.aio.PartitionContext
  - fullName: ', '
    name: ', '
  - fullName: azure.eventhub.CloseReason
    name: CloseReason
    uid: azure.eventhub.CloseReason
  - fullName: ']'
    name: ']'
  - fullName: ']'
    name: ']'
  uid: Callable[[azure.eventhub.aio.PartitionContext, azure.eventhub.CloseReason]]
- fullName: Callable[azure.eventhub.aio.PartitionContext, List[azure.eventhub.EventData]]
  name: Callable[PartitionContext, List[EventData]]
  spec.python:
  - fullName: Callable
    name: Callable
    uid: Callable
  - fullName: '['
    name: '['
  - fullName: azure.eventhub.aio.PartitionContext
    name: PartitionContext
    uid: azure.eventhub.aio.PartitionContext
  - fullName: ', '
    name: ', '
  - fullName: List
    name: List
    uid: List
  - fullName: '['
    name: '['
  - fullName: azure.eventhub.EventData
    name: EventData
    uid: azure.eventhub.EventData
  - fullName: ']'
    name: ']'
  - fullName: ']'
    name: ']'
  uid: Callable[azure.eventhub.aio.PartitionContext, List[azure.eventhub.EventData]]
